; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -disable-output -print-mustexecute %s 2>&1 | FileCheck %s --check-prefixes=BOTH,SLSI
; RUN: opt -disable-output -print-mustexecute -print-mustexecute-use-explorer %s 2>&1 | FileCheck %s --check-prefixes=BOTH,ELSI

; Infinite loop.
; Make sure that the backedge is mustexec.
define void @test_no_exit_block(i1 %cond, i32 %a, i32 %b) {
; BOTH-LABEL: @test_no_exit_block(
; BOTH-NEXT:  entry:
; BOTH-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; BOTH:       loop: ; preds = [[BACKEDGE:%.*]], [[ENTRY:%.*]]
; BOTH-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE]] ] ; (mustexec in: loop)
; BOTH-NEXT:    br i1 [[COND:%.*]], label [[MAYBE_TAKEN:%.*]], label [[BACKEDGE]] ; (mustexec in: loop)
; BOTH:       maybe_taken: ; preds = [[LOOP]]
; BOTH-NEXT:    [[DIV:%.*]] = sdiv i32 [[A:%.*]], [[B:%.*]] ; no mustexec loop
; BOTH-NEXT:    br label [[BACKEDGE]] ; no mustexec loop
; BOTH:       backedge: ; preds = [[MAYBE_TAKEN]], [[LOOP]]
; BOTH-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1 ; (mustexec in: loop)
; BOTH-NEXT:    br label [[LOOP]] ; (mustexec in: loop)
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  br i1 %cond, label %maybe_taken, label %backedge

maybe_taken:
  %div = sdiv i32 %a, %b
  br label %backedge

backedge:
  %iv.next = add i32 %iv, 1
  br label %loop
}

; Unlike the test before, we can say that backedge is mustexec, which is the
; correct behavior.
define void @test_impossible_exit_on_latch(i1 %cond, i32 %a, i32 %b) {
;
; BOTH-LABEL: @test_impossible_exit_on_latch(
; BOTH-NEXT:  entry:
; BOTH-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; BOTH:       loop: ; preds = [[BACKEDGE:%.*]], [[ENTRY:%.*]]
; BOTH-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE]] ] ; (mustexec in: loop)
; BOTH-NEXT:    br i1 [[COND:%.*]], label [[MAYBE_TAKEN:%.*]], label [[BACKEDGE]] ; (mustexec in: loop)
; BOTH:       maybe_taken: ; preds = [[LOOP]]
; BOTH-NEXT:    [[DIV:%.*]] = sdiv i32 [[A:%.*]], [[B:%.*]] ; no mustexec loop
; BOTH-NEXT:    br label [[BACKEDGE]] ; no mustexec loop
; BOTH:       backedge: ; preds = [[MAYBE_TAKEN]], [[LOOP]]
; BOTH-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1 ; (mustexec in: loop)
; BOTH-NEXT:    br i1 true, label [[LOOP]], label [[EXIT:%.*]] ; (mustexec in: loop)
; BOTH:       exit: ; preds = [[BACKEDGE]]
; BOTH-NEXT:    ret void ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  br i1 %cond, label %maybe_taken, label %backedge

maybe_taken:
  %div = sdiv i32 %a, %b
  br label %backedge

backedge:
  %iv.next = add i32 %iv, 1
  br i1 true, label %loop, label %exit

exit:
  ret void
}

; Make sure that sdiv is NOT marked as mustexec.
define void @test_impossible_exit_in_untaken_block(i1 %cond, i32 %a, i32 %b, i32* %p) {
; SLSI-LABEL: @test_impossible_exit_in_untaken_block(
; SLSI-NEXT:  entry:
; SLSI-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; SLSI:       loop: ; preds = [[BACKEDGE:%.*]], [[ENTRY:%.*]]
; SLSI-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE]] ] ; (mustexec in: loop)
; SLSI-NEXT:    br i1 [[COND:%.*]], label [[MAYBE_TAKEN:%.*]], label [[BACKEDGE]] ; (mustexec in: loop)
; SLSI:       maybe_taken: ; preds = [[LOOP]]
; SLSI-NEXT:    [[DIV:%.*]] = sdiv i32 [[A:%.*]], [[B:%.*]] ; no mustexec loop
; SLSI-NEXT:    store i32 [[DIV]], i32* [[P:%.*]] ; no mustexec loop
; SLSI-NEXT:    br i1 true, label [[BACKEDGE]], label [[EXIT:%.*]] ; no mustexec loop
; SLSI:       backedge: ; preds = [[MAYBE_TAKEN]], [[LOOP]]
; SLSI-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1 ; (mustexec in: loop)
; SLSI-NEXT:    br label [[LOOP]] ; (mustexec in: loop)
; SLSI:       exit: ; preds = [[MAYBE_TAKEN]]
; SLSI-NEXT:    ret void ; no mustexec loop
;
; ELSI-LABEL: @test_impossible_exit_in_untaken_block(
; ELSI-NEXT:  entry:
; ELSI-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; ELSI:       loop: ; preds = [[BACKEDGE:%.*]], [[ENTRY:%.*]]
; ELSI-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE]] ] ; (mustexec in: loop)
; ELSI-NEXT:    br i1 [[COND:%.*]], label [[MAYBE_TAKEN:%.*]], label [[BACKEDGE]] ; (mustexec in: loop)
; ELSI:       maybe_taken: ; preds = [[LOOP]]
; ELSI-NEXT:    [[DIV:%.*]] = sdiv i32 [[A:%.*]], [[B:%.*]] ; no mustexec loop
; ELSI-NEXT:    store i32 [[DIV]], i32* [[P:%.*]] ; no mustexec loop
; ELSI-NEXT:    br i1 true, label [[BACKEDGE]], label [[EXIT:%.*]] ; no mustexec loop
; ELSI:       backedge: ; preds = [[MAYBE_TAKEN]], [[LOOP]]
; ELSI-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1 ; no mustexec loop
; ELSI-NEXT:    br label [[LOOP]] ; no mustexec loop
; ELSI:       exit: ; preds = [[MAYBE_TAKEN]]
; ELSI-NEXT:    ret void ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  br i1 %cond, label %maybe_taken, label %backedge

maybe_taken:
  %div = sdiv i32 %a, %b
  store i32 %div, i32* %p
  br i1 true, label %backedge, label %exit

backedge:
  %iv.next = add i32 %iv, 1
  br label %loop

exit:
  ret void
}
