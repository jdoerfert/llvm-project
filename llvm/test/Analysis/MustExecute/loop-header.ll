; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -disable-output -print-mustexecute %s 2>&1 | FileCheck %s --check-prefixes=BOTH,SLSI
; RUN: opt -disable-output -print-mustexecute -print-mustexecute-use-explorer %s 2>&1 | FileCheck %s --check-prefixes=BOTH,ELSI

define i1 @header_with_icf(i32* noalias %p, i32 %high) {
;
; BOTH-LABEL: @header_with_icf(
; BOTH-NEXT:  entry:
; BOTH-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; BOTH:       loop: ; preds = [[LOOP]], [[ENTRY:%.*]]
; BOTH-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ] ; (mustexec in: loop)
; BOTH-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in: loop)
; BOTH-NEXT:    call void @maythrow_and_use(i32 [[V]]) ; (mustexec in: loop)
; BOTH-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; no mustexec loop
; BOTH-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; no mustexec loop
; BOTH-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; no mustexec loop
; BOTH:       exit: ; preds = [[LOOP]]
; BOTH-NEXT:    ret i1 false ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [0, %entry], [%iv.next, %loop]
  %v = load i32, i32* %p
  call void @maythrow_and_use(i32 %v)
  %iv.next = add nsw nuw i32 %iv, 1
  %exit.test = icmp slt i32 %iv, %high
  br i1 %exit.test, label %exit, label %loop

exit:
  ret i1 false
}

define i1 @split_header(i32* noalias %p, i32 %high) {
;
; BOTH-LABEL: @split_header(
; BOTH-NEXT:  entry:
; BOTH-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; BOTH:       loop: ; preds = [[NEXT:%.*]], [[ENTRY:%.*]]
; BOTH-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[NEXT]] ] ; (mustexec in: loop)
; BOTH-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in: loop)
; BOTH-NEXT:    br label [[NEXT]] ; (mustexec in: loop)
; BOTH:       next: ; preds = [[LOOP]]
; SLSI-NEXT:    call void @maythrow_and_use(i32 [[V]]) ; no mustexec loop
; ELSI-NEXT:    call void @maythrow_and_use(i32 [[V]]) ; (mustexec in: loop)
; BOTH-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; no mustexec loop
; BOTH-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; no mustexec loop
; BOTH-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; no mustexec loop
; BOTH:       exit: ; preds = [[NEXT]]
; BOTH-NEXT:    ret i1 false ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [0, %entry], [%iv.next, %next]
  %v = load i32, i32* %p
  br label %next
next:
  call void @maythrow_and_use(i32 %v)
  %iv.next = add nsw nuw i32 %iv, 1
  %exit.test = icmp slt i32 %iv, %high
  br i1 %exit.test, label %exit, label %loop

exit:
  ret i1 false
}

; FIXME: everything in inner loop header should be must execute
; for outer as well
define i1 @nested(i32* noalias %p, i32 %high) {
;
; SLSI-LABEL: @nested(
; SLSI-NEXT:  entry:
; SLSI-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; SLSI:       loop: ; preds = [[NEXT:%.*]], [[ENTRY:%.*]]
; SLSI-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[NEXT]] ] ; (mustexec in: loop)
; SLSI-NEXT:    br label [[INNER_LOOP:%.*]] ; (mustexec in: loop)
; SLSI:       inner_loop: ; preds = [[INNER_LOOP]], [[LOOP]]
; SLSI-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in: inner_loop)
; SLSI-NEXT:    [[INNER_TEST:%.*]] = icmp eq i32 [[V]], 0 ; (mustexec in: inner_loop)
; SLSI-NEXT:    br i1 [[INNER_TEST]], label [[INNER_LOOP]], label [[NEXT]] ; (mustexec in: inner_loop)
; SLSI:       next: ; preds = [[INNER_LOOP]]
; SLSI-NEXT:    call void @maythrow_and_use(i32 [[V]]) ; no mustexec loop
; SLSI-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; no mustexec loop
; SLSI-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; no mustexec loop
; SLSI-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; no mustexec loop
; SLSI:       exit: ; preds = [[NEXT]]
; SLSI-NEXT:    ret i1 false ; no mustexec loop
;
; ELSI-LABEL: @nested(
; ELSI-NEXT:  entry:
; ELSI-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; ELSI:       loop: ; preds = [[NEXT:%.*]], [[ENTRY:%.*]]
; ELSI-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[NEXT]] ] ; (mustexec in: loop)
; ELSI-NEXT:    br label [[INNER_LOOP:%.*]] ; (mustexec in: loop)
; ELSI:       inner_loop: ; preds = [[INNER_LOOP]], [[LOOP]]
; ELSI-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in 2 loops: loop, inner_loop)
; ELSI-NEXT:    [[INNER_TEST:%.*]] = icmp eq i32 [[V]], 0 ; (mustexec in 2 loops: loop, inner_loop)
; ELSI-NEXT:    br i1 [[INNER_TEST]], label [[INNER_LOOP]], label [[NEXT]] ; (mustexec in 2 loops: loop, inner_loop)
; ELSI:       next: ; preds = [[INNER_LOOP]]
; ELSI-NEXT:    call void @maythrow_and_use(i32 [[V]]) ; no mustexec loop
; ELSI-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; no mustexec loop
; ELSI-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; no mustexec loop
; ELSI-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; no mustexec loop
; ELSI:       exit: ; preds = [[NEXT]]
; ELSI-NEXT:    ret i1 false ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [0, %entry], [%iv.next, %next]
  br label %inner_loop

inner_loop:
  %v = load i32, i32* %p
  %inner.test = icmp eq i32 %v, 0
  br i1 %inner.test, label %inner_loop, label %next

next:
  call void @maythrow_and_use(i32 %v)
  %iv.next = add nsw nuw i32 %iv, 1
  %exit.test = icmp slt i32 %iv, %high
  br i1 %exit.test, label %exit, label %loop

exit:
  ret i1 false
}

define i1 @nested_no_throw(i32* noalias %p, i32 %high) {
;
; SLSI-LABEL: @nested_no_throw(
; SLSI-NEXT:  entry:
; SLSI-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; SLSI:       loop: ; preds = [[NEXT:%.*]], [[ENTRY:%.*]]
; SLSI-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[NEXT]] ] ; (mustexec in: loop)
; SLSI-NEXT:    br label [[INNER_LOOP:%.*]] ; (mustexec in: loop)
; SLSI:       inner_loop: ; preds = [[INNER_LOOP]], [[LOOP]]
; SLSI-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in 2 loops: inner_loop, loop)
; SLSI-NEXT:    store i32 1, i32* [[P]] ; (mustexec in 2 loops: inner_loop, loop)
; SLSI-NEXT:    [[INNER_TEST:%.*]] = icmp eq i32 [[V]], 0 ; (mustexec in 2 loops: inner_loop, loop)
; SLSI-NEXT:    br i1 [[INNER_TEST]], label [[INNER_LOOP]], label [[NEXT]] ; (mustexec in 2 loops: inner_loop, loop)
; SLSI:       next: ; preds = [[INNER_LOOP]]
; FIXME the following three lines are not correct ( https://llvm.org/PR42682 )
; SLSI-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; (mustexec in: loop)
; SLSI-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; (mustexec in: loop)
; SLSI-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; (mustexec in: loop)
; SLSI:       exit: ; preds = [[NEXT]]
; SLSI-NEXT:    ret i1 false ; no mustexec loop
;
; ELSI-LABEL: @nested_no_throw(
; ELSI-NEXT:  entry:
; ELSI-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; ELSI:       loop: ; preds = [[NEXT:%.*]], [[ENTRY:%.*]]
; ELSI-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[NEXT]] ] ; (mustexec in: loop)
; ELSI-NEXT:    br label [[INNER_LOOP:%.*]] ; (mustexec in: loop)
; ELSI:       inner_loop: ; preds = [[INNER_LOOP]], [[LOOP]]
; ELSI-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in 2 loops: loop, inner_loop)
; ELSI-NEXT:    store i32 1, i32* [[P]] ; (mustexec in 2 loops: loop, inner_loop)
; ELSI-NEXT:    [[INNER_TEST:%.*]] = icmp eq i32 [[V]], 0 ; (mustexec in 2 loops: loop, inner_loop)
; ELSI-NEXT:    br i1 [[INNER_TEST]], label [[INNER_LOOP]], label [[NEXT]] ; (mustexec in 2 loops: loop, inner_loop)
; ELSI:       next: ; preds = [[INNER_LOOP]]
; ELSI-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; no mustexec loop
; ELSI-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; no mustexec loop
; ELSI-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; no mustexec loop
; ELSI:       exit: ; preds = [[NEXT]]
; ELSI-NEXT:    ret i1 false ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [0, %entry], [%iv.next, %next]
  br label %inner_loop

inner_loop:
  %v = load i32, i32* %p
  store i32 1, i32* %p
  %inner.test = icmp eq i32 %v, 0
  br i1 %inner.test, label %inner_loop, label %next

next:
  %iv.next = add nsw nuw i32 %iv, 1
  %exit.test = icmp slt i32 %iv, %high
  br i1 %exit.test, label %exit, label %loop

exit:
  ret i1 false
}

; Since all the instructions in the loop dominate the only exit
; and there's no implicit control flow in the loop, all must execute
; FIXME: handled by loop safety info, test it
define i1 @nothrow_loop(i32* noalias %p, i32 %high) {
;
; BOTH-LABEL: @nothrow_loop(
; BOTH-NEXT:  entry:
; BOTH-NEXT:    br label [[LOOP:%.*]] ; no mustexec loop
; BOTH:       loop: ; preds = [[NEXT:%.*]], [[ENTRY:%.*]]
; BOTH-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[NEXT]] ] ; (mustexec in: loop)
; BOTH-NEXT:    br label [[NEXT]] ; (mustexec in: loop)
; BOTH:       next: ; preds = [[LOOP]]
; BOTH-NEXT:    [[V:%.*]] = load i32, i32* [[P:%.*]] ; (mustexec in: loop)
; BOTH-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1 ; (mustexec in: loop)
; BOTH-NEXT:    [[EXIT_TEST:%.*]] = icmp slt i32 [[IV]], [[HIGH:%.*]] ; (mustexec in: loop)
; BOTH-NEXT:    br i1 [[EXIT_TEST]], label [[EXIT:%.*]], label [[LOOP]] ; (mustexec in: loop)
; BOTH:       exit: ; preds = [[NEXT]]
; BOTH-NEXT:    ret i1 false ; no mustexec loop
;
entry:
  br label %loop

loop:
  %iv = phi i32 [0, %entry], [%iv.next, %next]
  br label %next
next:
  %v = load i32, i32* %p
  %iv.next = add nsw nuw i32 %iv, 1
  %exit.test = icmp slt i32 %iv, %high
  br i1 %exit.test, label %exit, label %loop

exit:
  ret i1 false
}


declare void @maythrow_and_use(i32)
