; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -argpromotion -S | FileCheck %s --check-prefixes=ALL,ARGPROMOTION
; RUN: opt < %s -passes=argpromotion -S | FileCheck %s --check-prefixes=ALL,ARGPROMOTION
; RUN: opt -S -passes=attributor -aa-pipeline='basic-aa' -attributor-disable=false -attributor-max-iterations-verify -attributor-max-iterations=3 < %s | FileCheck %s --check-prefixes=ALL,ATTRIBUTOR

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%union.u = type { x86_fp80 }
%struct.s = type { double, i16, i8, [5 x i8] }
%struct.Foo = type { i32, i64 }

define x86_fp80 @run(%struct.Foo* %a, %struct.s* %b, i8* %i8, i64* %i64a, i64* %i64b) {
; ARGPROMOTION-LABEL: define {{[^@]+}}@run
; ARGPROMOTION-SAME: (%struct.Foo* [[A:%.*]], %struct.s* [[B:%.*]], i8* [[I8:%.*]], i64* [[I64A:%.*]], i64* [[I64B:%.*]])
; ARGPROMOTION-NEXT:  entry:
; ARGPROMOTION-NEXT:    [[BC:%.*]] = bitcast %struct.s* [[B]] to %union.u*
; ARGPROMOTION-NEXT:    [[V0:%.*]] = tail call i8 @UseLongDoubleUnsafely(%union.u* byval align 16 [[BC]])
; ARGPROMOTION-NEXT:    store i8 [[V0]], i8* [[I8]]
; ARGPROMOTION-NEXT:    [[BC_0:%.*]] = getelementptr [[UNION_U:%.*]], %union.u* [[BC]], i32 0, i32 0
; ARGPROMOTION-NEXT:    [[BC_0_VAL:%.*]] = load x86_fp80, x86_fp80* [[BC_0]]
; ARGPROMOTION-NEXT:    [[V1:%.*]] = tail call x86_fp80 @UseLongDoubleSafely(x86_fp80 [[BC_0_VAL]])
; ARGPROMOTION-NEXT:    [[V2:%.*]] = call i64 @AccessPaddingOfStruct(%struct.Foo* [[A]])
; ARGPROMOTION-NEXT:    store i64 [[V2]], i64* [[I64A]]
; ARGPROMOTION-NEXT:    [[V3:%.*]] = call i64 @CaptureAStruct(%struct.Foo* [[A]])
; ARGPROMOTION-NEXT:    store i64 [[V3]], i64* [[I64B]]
; ARGPROMOTION-NEXT:    ret x86_fp80 [[V1]]
;
; ATTRIBUTOR-LABEL: define {{[^@]+}}@run
; ATTRIBUTOR-SAME: (%struct.Foo* nocapture readonly [[A:%.*]], %struct.s* nocapture readonly [[B:%.*]], i8* nocapture writeonly [[I8:%.*]], i64* nocapture writeonly [[I64A:%.*]], i64* nocapture readnone [[I64B:%.*]])
; ATTRIBUTOR-NEXT:  entry:
<<<<<<< HEAD
; ATTRIBUTOR-NEXT:    [[DOTCAST:%.*]] = bitcast %struct.s* [[B]] to %union.u*
; ATTRIBUTOR-NEXT:    [[DOTCAST1:%.*]] = bitcast %struct.s* [[B]] to %union.u*
; ATTRIBUTOR-NEXT:    [[V0:%.*]] = tail call i8 @UseLongDoubleUnsafely(%union.u* nocapture readonly byval align 16 [[DOTCAST]])
; ATTRIBUTOR-NEXT:    store i8 [[V0]], i8* [[I8]]
; ATTRIBUTOR-NEXT:    [[DOTCAST2:%.*]] = bitcast %struct.s* [[B]] to %union.u*
; ATTRIBUTOR-NEXT:    [[V2:%.*]] = call i64 @AccessPaddingOfStruct(%struct.Foo* nocapture [[A]])
; ATTRIBUTOR-NEXT:    store i64 [[V2]], i64* [[I64A]]
; ATTRIBUTOR-NEXT:    [[V3:%.*]] = call i64 @CaptureAStruct(%struct.Foo* [[A]])
||||||| parent of 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-NEXT:    [[BC:%.*]] = bitcast %struct.s* [[B:%.*]] to %union.u*
; ATTRIBUTOR-NEXT:    [[V0:%.*]] = tail call i8 @UseLongDoubleUnsafely(%union.u* nocapture readonly byval align 16 [[BC]])
; ATTRIBUTOR-NEXT:    store i8 [[V0]], i8* [[I8:%.*]]
; ATTRIBUTOR-NEXT:    [[V1:%.*]] = tail call x86_fp80 @UseLongDoubleSafely(%union.u* nocapture readonly byval align 16 [[BC]])
; ATTRIBUTOR-NEXT:    [[V2:%.*]] = call i64 @AccessPaddingOfStruct(%struct.Foo* nocapture [[A:%.*]])
; ATTRIBUTOR-NEXT:    store i64 [[V2]], i64* [[I64A:%.*]]
; ATTRIBUTOR-NEXT:    [[V3:%.*]] = call i64 @CaptureAStruct(%struct.Foo* [[A]])
=======
; ATTRIBUTOR-NEXT:    [[BC:%.*]] = bitcast %struct.s* [[B]] to %union.u*
; ATTRIBUTOR-NEXT:    [[V0:%.*]] = tail call i8 @UseLongDoubleUnsafely(%union.u* nocapture readonly byval align 16 [[BC]])
; ATTRIBUTOR-NEXT:    store i8 [[V0]], i8* [[I8]]
; ATTRIBUTOR-NEXT:    [[V1:%.*]] = tail call x86_fp80 @UseLongDoubleSafely(%union.u* nocapture readonly byval align 16 [[BC]])
; ATTRIBUTOR-NEXT:    [[V2:%.*]] = call i64 @AccessPaddingOfStruct(%struct.Foo* nocapture readonly [[A]])
; ATTRIBUTOR-NEXT:    store i64 [[V2]], i64* [[I64A]]
; ATTRIBUTOR-NEXT:    [[V3:%.*]] = call i64 @CaptureAStruct(%struct.Foo* nocapture readnone [[A]])
>>>>>>> 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-NEXT:    unreachable
;
entry:
  %bc = bitcast %struct.s* %b to %union.u*
  %v0 = tail call i8 @UseLongDoubleUnsafely(%union.u* byval align 16 %bc)
  store i8 %v0, i8* %i8
  %v1 = tail call x86_fp80 @UseLongDoubleSafely(%union.u* byval align 16 %bc)
  %v2 = call i64 @AccessPaddingOfStruct(%struct.Foo* %a)
  store i64 %v2, i64* %i64a
  %v3 = call i64 @CaptureAStruct(%struct.Foo* %a)
  store i64 %v3, i64* %i64b
  ret x86_fp80 %v1
}

define internal i8 @UseLongDoubleUnsafely(%union.u* byval align 16 %arg) {
; ARGPROMOTION-LABEL: define {{[^@]+}}@UseLongDoubleUnsafely
; ARGPROMOTION-SAME: (%union.u* byval align 16 [[ARG:%.*]])
; ARGPROMOTION-NEXT:  entry:
; ARGPROMOTION-NEXT:    [[BITCAST:%.*]] = bitcast %union.u* [[ARG]] to %struct.s*
; ARGPROMOTION-NEXT:    [[GEP:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.s* [[BITCAST]], i64 0, i32 2
; ARGPROMOTION-NEXT:    [[RESULT:%.*]] = load i8, i8* [[GEP]]
; ARGPROMOTION-NEXT:    ret i8 [[RESULT]]
;
; ATTRIBUTOR-LABEL: define {{[^@]+}}@UseLongDoubleUnsafely
; ATTRIBUTOR-SAME: (%union.u* nocapture readonly byval align 16 [[ARG:%.*]])
; ATTRIBUTOR-NEXT:  entry:
; ATTRIBUTOR-NEXT:    [[BITCAST:%.*]] = bitcast %union.u* [[ARG]] to %struct.s*
; ATTRIBUTOR-NEXT:    [[GEP:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.s* [[BITCAST]], i64 0, i32 2
; ATTRIBUTOR-NEXT:    [[RESULT:%.*]] = load i8, i8* [[GEP]]
; ATTRIBUTOR-NEXT:    ret i8 [[RESULT]]
;
entry:
  %bitcast = bitcast %union.u* %arg to %struct.s*
  %gep = getelementptr inbounds %struct.s, %struct.s* %bitcast, i64 0, i32 2
  %result = load i8, i8* %gep
  ret i8 %result
}

define internal x86_fp80 @UseLongDoubleSafely(%union.u* byval align 16 %arg) {
; ARGPROMOTION-LABEL: define {{[^@]+}}@UseLongDoubleSafely
; ARGPROMOTION-SAME: (x86_fp80 [[ARG_0:%.*]])
; ARGPROMOTION-NEXT:    [[ARG:%.*]] = alloca [[UNION_U:%.*]], align 16
; ARGPROMOTION-NEXT:    [[DOT0:%.*]] = getelementptr [[UNION_U]], %union.u* [[ARG]], i32 0, i32 0
; ARGPROMOTION-NEXT:    store x86_fp80 [[ARG_0]], x86_fp80* [[DOT0]]
; ARGPROMOTION-NEXT:    [[GEP:%.*]] = getelementptr inbounds [[UNION_U]], %union.u* [[ARG]], i64 0, i32 0
; ARGPROMOTION-NEXT:    [[FP80:%.*]] = load x86_fp80, x86_fp80* [[GEP]]
; ARGPROMOTION-NEXT:    ret x86_fp80 [[FP80]]
;
<<<<<<< HEAD
||||||| parent of 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-LABEL: define {{[^@]+}}@UseLongDoubleSafely
; ATTRIBUTOR-SAME: (%union.u* nocapture readonly byval align 16 [[ARG:%.*]])
; ATTRIBUTOR-NEXT:    [[GEP:%.*]] = getelementptr inbounds [[UNION_U:%.*]], %union.u* [[ARG:%.*]], i64 0, i32 0
; ATTRIBUTOR-NEXT:    [[FP80:%.*]] = load x86_fp80, x86_fp80* [[GEP]], align 16
; ATTRIBUTOR-NEXT:    ret x86_fp80 [[FP80]]
;
=======
; ATTRIBUTOR-LABEL: define {{[^@]+}}@UseLongDoubleSafely
; ATTRIBUTOR-SAME: (%union.u* nocapture readonly byval align 16 [[ARG:%.*]])
; ATTRIBUTOR-NEXT:    [[GEP:%.*]] = getelementptr inbounds [[UNION_U:%.*]], %union.u* [[ARG]], i64 0, i32 0
; ATTRIBUTOR-NEXT:    [[FP80:%.*]] = load x86_fp80, x86_fp80* [[GEP]], align 16
; ATTRIBUTOR-NEXT:    ret x86_fp80 [[FP80]]
;
>>>>>>> 2bf5733254a... FIXES FIXES FIXES
  %gep = getelementptr inbounds %union.u, %union.u* %arg, i64 0, i32 0
  %fp80 = load x86_fp80, x86_fp80* %gep
  ret x86_fp80 %fp80
}

define internal i64 @AccessPaddingOfStruct(%struct.Foo* byval %a) {
; ARGPROMOTION-LABEL: define {{[^@]+}}@AccessPaddingOfStruct
; ARGPROMOTION-SAME: (%struct.Foo* byval [[A:%.*]])
; ARGPROMOTION-NEXT:    [[P:%.*]] = bitcast %struct.Foo* [[A]] to i64*
; ARGPROMOTION-NEXT:    [[V:%.*]] = load i64, i64* [[P]]
; ARGPROMOTION-NEXT:    ret i64 [[V]]
;
; ATTRIBUTOR-LABEL: define {{[^@]+}}@AccessPaddingOfStruct
; ATTRIBUTOR-SAME: (%struct.Foo* nocapture readonly byval [[A:%.*]])
; ATTRIBUTOR-NEXT:    [[P:%.*]] = bitcast %struct.Foo* [[A]] to i64*
; ATTRIBUTOR-NEXT:    [[V:%.*]] = load i64, i64* [[P]]
; ATTRIBUTOR-NEXT:    ret i64 [[V]]
;
  %p = bitcast %struct.Foo* %a to i64*
  %v = load i64, i64* %p
  ret i64 %v
}

define internal i64 @CaptureAStruct(%struct.Foo* byval %a) {
; ARGPROMOTION-LABEL: define {{[^@]+}}@CaptureAStruct
; ARGPROMOTION-SAME: (%struct.Foo* byval [[A:%.*]])
; ARGPROMOTION-NEXT:  entry:
; ARGPROMOTION-NEXT:    [[A_PTR:%.*]] = alloca %struct.Foo*
; ARGPROMOTION-NEXT:    br label [[LOOP:%.*]]
; ARGPROMOTION:       loop:
; ARGPROMOTION-NEXT:    [[PHI:%.*]] = phi %struct.Foo* [ null, [[ENTRY:%.*]] ], [ [[GEP:%.*]], [[LOOP]] ]
; ARGPROMOTION-NEXT:    [[TMP0:%.*]] = phi %struct.Foo* [ [[A]], [[ENTRY]] ], [ [[TMP0]], [[LOOP]] ]
; ARGPROMOTION-NEXT:    store %struct.Foo* [[PHI]], %struct.Foo** [[A_PTR]]
; ARGPROMOTION-NEXT:    [[GEP]] = getelementptr [[STRUCT_FOO:%.*]], %struct.Foo* [[A]], i64 0
; ARGPROMOTION-NEXT:    br label [[LOOP]]
;
; ATTRIBUTOR-LABEL: define {{[^@]+}}@CaptureAStruct
<<<<<<< HEAD
; ATTRIBUTOR-SAME: (%struct.Foo* writeonly byval [[A:%.*]])
||||||| parent of 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-SAME: (%struct.Foo* byval [[A:%.*]])
=======
; ATTRIBUTOR-SAME: (%struct.Foo* nocapture readnone byval [[A:%.*]])
>>>>>>> 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-NEXT:  entry:
; ATTRIBUTOR-NEXT:    br label [[LOOP:%.*]]
; ATTRIBUTOR:       loop:
; ATTRIBUTOR-NEXT:    [[PHI:%.*]] = phi %struct.Foo* [ null, [[ENTRY:%.*]] ], [ [[GEP:%.*]], [[LOOP]] ]
<<<<<<< HEAD
; ATTRIBUTOR-NEXT:    [[TMP0:%.*]] = phi %struct.Foo* [ [[A]], [[ENTRY]] ], [ [[TMP0]], [[LOOP]] ]
; ATTRIBUTOR-NEXT:    store %struct.Foo* [[PHI]], %struct.Foo** [[A_PTR]], align 8
||||||| parent of 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-NEXT:    [[TMP0:%.*]] = phi %struct.Foo* [ [[A:%.*]], [[ENTRY]] ], [ [[TMP0]], [[LOOP]] ]
; ATTRIBUTOR-NEXT:    store %struct.Foo* [[PHI]], %struct.Foo** [[A_PTR]], align 8
=======
; ATTRIBUTOR-NEXT:    [[TMP0:%.*]] = phi %struct.Foo* [ [[A]], [[ENTRY]] ], [ [[TMP0]], [[LOOP]] ]
>>>>>>> 2bf5733254a... FIXES FIXES FIXES
; ATTRIBUTOR-NEXT:    [[GEP]] = getelementptr [[STRUCT_FOO:%.*]], %struct.Foo* [[A]], i64 0
; ATTRIBUTOR-NEXT:    br label [[LOOP]]
;
entry:
  %a_ptr = alloca %struct.Foo*
  br label %loop

loop:
  %phi = phi %struct.Foo* [ null, %entry ], [ %gep, %loop ]
  %0   = phi %struct.Foo* [ %a, %entry ],   [ %0, %loop ]
  store %struct.Foo* %phi, %struct.Foo** %a_ptr
  %gep = getelementptr %struct.Foo, %struct.Foo* %a, i64 0
  br label %loop
}
