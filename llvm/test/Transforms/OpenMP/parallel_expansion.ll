; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -S -openmpopt < %s | FileCheck %s
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

%struct.ident_t = type { i32, i32, i32, i32, i8* }

@.str = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@0 = private unnamed_addr global %struct.ident_t { i32 0, i32 2, i32 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i32 0, i32 0) }, align 8

;    void adjacent_parallel_1(void) {
;    #pragma omp parallel
;      { foo(); }
;    #pragma omp parallel
;      { foo(); }
;    }
define void @adjacent_parallel_1() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_1()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OMP_GLOBAL_THREAD_NUM:%.*]] = call i32 @__kmpc_global_thread_num(%struct.ident_t* @0)
; CHECK-NEXT:    br label [[OMP_PARALLEL:%.*]]
; CHECK:       omp_parallel:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @adjacent_parallel_1..omp_par to void (i32*, i32*, ...)*))
; CHECK-NEXT:    br label [[OMP_PAR_EXIT_SPLIT:%.*]]
; CHECK:       omp.par.exit.split:
; CHECK-NEXT:    br label [[ENTRY_SPLIT_SPLIT:%.*]]
; CHECK:       entry.split.split:
; CHECK-NEXT:    ret void
;
entry:
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined. to void (i32*, i32*, ...)*))
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..1 to void (i32*, i32*, ...)*))
  ret void
}

define internal void @.omp_outlined.(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined.
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..1(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..1
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

;    void adjacent_parallel_2(void) {
;    #pragma omp parallel
;      { foo(); }
;    #pragma omp parallel
;      { bar(0); }
;    #pragma omp parallel
;      { foo(); }
;    #pragma omp parallel
;      { bar(1); }
;    }
define void @adjacent_parallel_2() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_2()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OMP_GLOBAL_THREAD_NUM:%.*]] = call i32 @__kmpc_global_thread_num(%struct.ident_t* @0)
; CHECK-NEXT:    br label [[OMP_PARALLEL:%.*]]
; CHECK:       omp_parallel:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @adjacent_parallel_2..omp_par to void (i32*, i32*, ...)*))
; CHECK-NEXT:    br label [[OMP_PAR_EXIT_SPLIT:%.*]]
; CHECK:       omp.par.exit.split:
; CHECK-NEXT:    br label [[ENTRY_SPLIT_SPLIT:%.*]]
; CHECK:       entry.split.split:
; CHECK-NEXT:    ret void
;
entry:
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..2 to void (i32*, i32*, ...)*))
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..3 to void (i32*, i32*, ...)*))
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..4 to void (i32*, i32*, ...)*))
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..5 to void (i32*, i32*, ...)*))
  ret void
}

define internal void @.omp_outlined..2(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..2
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..3(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..3
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @bar(i32 0)
; CHECK-NEXT:    ret void
;
entry:
  call void @bar(i32 0)
  ret void
}

define internal void @.omp_outlined..4(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..4
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..5(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..5
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @bar(i32 1)
; CHECK-NEXT:    ret void
;
entry:
  call void @bar(i32 1)
  ret void
}

;    void adjacent_parallel_3(int a, int b) {
;    #pragma omp parallel
;      { bar(a); }
;    #pragma omp parallel
;      { bar(a); }
;    #pragma omp parallel
;      { bar(b); }
;    #pragma omp parallel
;      { bar(b); }
;    }
define void @adjacent_parallel_3(i32 %a, i32 %b) {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_3
; CHECK-SAME: (i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[A]], i32* [[A_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    store i32 [[B]], i32* [[B_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    [[OMP_GLOBAL_THREAD_NUM:%.*]] = call i32 @__kmpc_global_thread_num(%struct.ident_t* @0)
; CHECK-NEXT:    br label [[OMP_PARALLEL:%.*]]
; CHECK:       omp_parallel:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* @0, i32 2, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*, i32*)* @adjacent_parallel_3..omp_par to void (i32*, i32*, ...)*), i32* [[A_ADDR]], i32* [[B_ADDR]])
; CHECK-NEXT:    br label [[OMP_PAR_EXIT_SPLIT:%.*]]
; CHECK:       omp.par.exit.split:
; CHECK-NEXT:    br label [[ENTRY_SPLIT_SPLIT:%.*]]
; CHECK:       entry.split.split:
; CHECK-NEXT:    ret void
;
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4, !tbaa !4
  store i32 %b, i32* %b.addr, align 4, !tbaa !4
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..6 to void (i32*, i32*, ...)*), i32* nonnull %a.addr)
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..7 to void (i32*, i32*, ...)*), i32* nonnull %a.addr)
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..8 to void (i32*, i32*, ...)*), i32* nonnull %b.addr)
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..9 to void (i32*, i32*, ...)*), i32* nonnull %b.addr)
  ret void
}

define internal void @.omp_outlined..6(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %a) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..6
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[A:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[A]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %a, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

define internal void @.omp_outlined..7(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %a) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..7
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[A:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[A]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %a, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

define internal void @.omp_outlined..8(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %b) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..8
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[B:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[B]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %b, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

define internal void @.omp_outlined..9(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %b) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..9
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[B:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[B]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %b, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

;    void adjacent_parallel_4(int a, int b) {
;    #pragma omp parallel
;      { bar(a); }
;      a = b;
;    #pragma omp parallel
;      { bar(a); }
;    #pragma omp parallel
;      { bar(b); }
;      a = b = 9;
;    #pragma omp parallel
;      { bar(b); }
;    }
define void @adjacent_parallel_4(i32 %a, i32 %b) {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_4
; CHECK-SAME: (i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[A]], i32* [[A_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    store i32 [[B]], i32* [[B_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..10 to void (i32*, i32*, ...)*), i32* nonnull [[A_ADDR]])
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[B_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    store i32 [[TMP]], i32* [[A_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    [[OMP_GLOBAL_THREAD_NUM:%.*]] = call i32 @__kmpc_global_thread_num(%struct.ident_t* @0)
; CHECK-NEXT:    br label [[OMP_PARALLEL:%.*]]
; CHECK:       omp_parallel:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* @0, i32 2, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*, i32*)* @adjacent_parallel_4..omp_par to void (i32*, i32*, ...)*), i32* [[A_ADDR]], i32* [[B_ADDR]])
; CHECK-NEXT:    br label [[OMP_PAR_EXIT_SPLIT:%.*]]
; CHECK:       omp.par.exit.split:
; CHECK-NEXT:    br label [[ENTRY_SPLIT_SPLIT:%.*]]
; CHECK:       entry.split.split:
; CHECK-NEXT:    store i32 9, i32* [[B_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    store i32 9, i32* [[A_ADDR]], align 4, !tbaa !0
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..13 to void (i32*, i32*, ...)*), i32* nonnull [[B_ADDR]])
; CHECK-NEXT:    ret void
;
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4, !tbaa !4
  store i32 %b, i32* %b.addr, align 4, !tbaa !4
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..10 to void (i32*, i32*, ...)*), i32* nonnull %a.addr)
  %tmp = load i32, i32* %b.addr, align 4, !tbaa !4
  store i32 %tmp, i32* %a.addr, align 4, !tbaa !4
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..11 to void (i32*, i32*, ...)*), i32* nonnull %a.addr)
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..12 to void (i32*, i32*, ...)*), i32* nonnull %b.addr)
  store i32 9, i32* %b.addr, align 4, !tbaa !4
  store i32 9, i32* %a.addr, align 4, !tbaa !4
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, i32*)* @.omp_outlined..13 to void (i32*, i32*, ...)*), i32* nonnull %b.addr)
  ret void
}

define internal void @.omp_outlined..10(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %a) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..10
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[A:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[A]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %a, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

define internal void @.omp_outlined..11(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %a) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..11
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[A:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[A]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %a, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

define internal void @.omp_outlined..12(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %b) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..12
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[B:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[B]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %b, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

define internal void @.omp_outlined..13(i32* noalias %.global_tid., i32* noalias %.bound_tid., i32* dereferenceable(4) %b) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..13
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], i32* dereferenceable(4) [[B:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[B]], align 4, !tbaa !0
; CHECK-NEXT:    call void @bar(i32 [[TMP]])
; CHECK-NEXT:    ret void
;
entry:
  %tmp = load i32, i32* %b, align 4, !tbaa !4
  call void @bar(i32 %tmp)
  ret void
}

;    void adjacent_parallel_5() {
;    #pragma omp parallel
;      { foo(); }
;      foo();
;    #pragma omp parallel
;      { foo(); }
;    }
define void @adjacent_parallel_5() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_5()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..14 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..15 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    ret void
;
entry:
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..14 to void (i32*, i32*, ...)*))
  call void @foo()
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..15 to void (i32*, i32*, ...)*))
  ret void
}

define internal void @.omp_outlined..14(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..14
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..15(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..15
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

;    void adjacent_parallel_6() {
;      foo();
;    #pragma omp parallel
;      { foo(); }
;    #pragma omp parallel
;      { foo(); }
;      foo();
;    }
define void @adjacent_parallel_6() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_6()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    [[OMP_GLOBAL_THREAD_NUM:%.*]] = call i32 @__kmpc_global_thread_num(%struct.ident_t* @0)
; CHECK-NEXT:    br label [[OMP_PARALLEL:%.*]]
; CHECK:       omp_parallel:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @adjacent_parallel_6..omp_par to void (i32*, i32*, ...)*))
; CHECK-NEXT:    br label [[OMP_PAR_EXIT_SPLIT:%.*]]
; CHECK:       omp.par.exit.split:
; CHECK-NEXT:    br label [[ENTRY_SPLIT_SPLIT:%.*]]
; CHECK:       entry.split.split:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..16 to void (i32*, i32*, ...)*))
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..17 to void (i32*, i32*, ...)*))
  call void @foo()
  ret void
}

define internal void @.omp_outlined..16(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..16
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..17(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..17
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

;    void adjacent_parallel_7() {
;    #pragma omp parallel
;      { foo(); }
;      readonly(0);
;    #pragma omp parallel
;      {
;        foo();
;      }
;    }
define void @adjacent_parallel_7() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_7()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..18 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @readonly(i32 0)
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..19 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    ret void
;
entry:
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..18 to void (i32*, i32*, ...)*))
  %call = call i32 @readonly(i32 0)
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..19 to void (i32*, i32*, ...)*))
  ret void
}

define internal void @.omp_outlined..18(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..18
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..19(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..19
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

;    void adjacent_parallel_8() {
;    #pragma omp parallel
;      { foo(); }
;      readnone(0);
;    #pragma omp parallel
;      {
;        foo();
;      }
;    }
define void @adjacent_parallel_8() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_8()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..20 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @readnone(i32 0)
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..21 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    ret void
;
entry:
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..20 to void (i32*, i32*, ...)*))
  %call = call i32 @readnone(i32 0)
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..21 to void (i32*, i32*, ...)*))
  ret void
}

define internal void @.omp_outlined..20(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..20
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..21(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..21
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

;    void adjacent_parallel_9() {
;    #pragma omp parallel
;      { foo(); }
;      if (readnone(0))
;    #pragma omp parallel
;      {
;        foo();
;      }
;    #pragma omp parallel
;      { foo(); }
;    }
define void @adjacent_parallel_9() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_9()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..22 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @readnone(i32 0)
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[CALL]], 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..23 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..24 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    ret void
;
entry:
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..22 to void (i32*, i32*, ...)*))
  %call = call i32 @readnone(i32 0)
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..23 to void (i32*, i32*, ...)*))
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..24 to void (i32*, i32*, ...)*))
  ret void
}

define internal void @.omp_outlined..22(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..22
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..23(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..23
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..24(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..24
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

;    void adjacent_parallel_10() {
;      if (readnone(0) == readonly(1))
;    #pragma omp parallel
;      {
;        foo();
;      } else
;    #pragma omp parallel
;      {
;        foo();
;      }
;    }
define void @adjacent_parallel_10() {
; CHECK-LABEL: define {{[^@]+}}@adjacent_parallel_10()
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @readnone(i32 0)
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 @readonly(i32 1)
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[CALL]], [[CALL1]]
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..25 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..26 to void (i32*, i32*, ...)*))
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret void
;
entry:
  %call = call i32 @readnone(i32 0)
  %call1 = call i32 @readonly(i32 1)
  %cmp = icmp eq i32 %call, %call1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..25 to void (i32*, i32*, ...)*))
  br label %if.end

if.else:                                          ; preds = %entry
  call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* nonnull @0, i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..26 to void (i32*, i32*, ...)*))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

define internal void @.omp_outlined..25(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..25
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

define internal void @.omp_outlined..26(i32* noalias %.global_tid., i32* noalias %.bound_tid.) {
; CHECK-LABEL: define {{[^@]+}}@.omp_outlined..26
; CHECK-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]])
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret void
;
entry:
  call void @foo()
  ret void
}

declare void @foo()
declare void @bar(i32)
declare i32 @readonly(i32) readonly
declare i32 @readnone(i32) readnone

declare !callback !2 void @__kmpc_fork_call(%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...)

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang"}
!2 = !{!3}
!3 = !{i64 2, i64 -1, i64 -1, i1 true}
!4 = !{!5, !5, i64 0}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
