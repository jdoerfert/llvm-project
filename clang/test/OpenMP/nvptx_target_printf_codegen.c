// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --include-generated-funcs
// Test target codegen - host bc file has to be created first.
// RUN: %clang_cc1 -verify -fopenmp -x c -triple powerpc64le-unknown-unknown -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm-bc %s -o %t-ppc-host.bc
// RUN: %clang_cc1 -verify -fopenmp -x c -triple nvptx64-unknown-unknown -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm %s -fopenmp-is-device -fopenmp-host-ir-file-path %t-ppc-host.bc -o - | FileCheck %s --check-prefix CHECK64
// RUN: %clang_cc1 -verify -fopenmp -x c -triple i386-unknown-unknown -fopenmp-targets=nvptx-nvidia-cuda -emit-llvm-bc %s -o %t-x86-host.bc
// RUN: %clang_cc1 -verify -fopenmp -x c -triple nvptx-unknown-unknown -fopenmp-targets=nvptx-nvidia-cuda -emit-llvm %s -fopenmp-is-device -fopenmp-host-ir-file-path %t-x86-host.bc -o - | FileCheck %s --check-prefix CHECK32
// expected-no-diagnostics
extern int printf(const char *, ...);

int CheckSimple() {
#pragma omp target
  {
    const char* fmt = "%d %lld %f";
    printf(fmt, 1, 2ll, 3.0);
  }

  return 0;
}

void CheckNoArgs() {
#pragma omp target
  {
    printf("hello, world!");
  }
}

// Check that printf's alloca happens in the entry block, not inside the if
// statement.
int foo;
void CheckAllocaIsInEntryBlock() {
#pragma omp target
  {
    if (foo) {
      printf("%d", 42);
    }
  }
}
// CHECK64-LABEL: @__omp_offloading_2a_cedcc9_CheckSimple_l11(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[FMT:%.*]] = alloca i8*, align 8
// CHECK64-NEXT:    [[TMP:%.*]] = alloca [[PRINTF_ARGS:%.*]], align 8
// CHECK64-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1:[0-9]+]], i1 false, i1 true)
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), i8** [[FMT]], align 8
// CHECK64-NEXT:    [[TMP1:%.*]] = load i8*, i8** [[FMT]], align 8
// CHECK64-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [[PRINTF_ARGS]], %printf_args* [[TMP]], i32 0, i32 0
// CHECK64-NEXT:    store i32 1, i32* [[TMP2]], align 4
// CHECK64-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[PRINTF_ARGS]], %printf_args* [[TMP]], i32 0, i32 1
// CHECK64-NEXT:    store i64 2, i64* [[TMP3]], align 8
// CHECK64-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [[PRINTF_ARGS]], %printf_args* [[TMP]], i32 0, i32 2
// CHECK64-NEXT:    store double 3.000000e+00, double* [[TMP4]], align 8
// CHECK64-NEXT:    [[TMP5:%.*]] = bitcast %printf_args* [[TMP]] to i8*
// CHECK64-NEXT:    [[TMP6:%.*]] = call i32 @vprintf(i8* [[TMP1]], i8* [[TMP5]])
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB1]], i1 false)
// CHECK64-NEXT:    ret void
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cedcc9_CheckNoArgs_l21(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1]], i1 false, i1 true)
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    [[TMP1:%.*]] = call i32 @vprintf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str1, i64 0, i64 0), i8* null)
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB1]], i1 false)
// CHECK64-NEXT:    ret void
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cedcc9_CheckAllocaIsInEntryBlock_l31(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[FOO_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    [[TMP:%.*]] = alloca [[PRINTF_ARGS_0:%.*]], align 8
// CHECK64-NEXT:    store i64 [[FOO:%.*]], i64* [[FOO_ADDR]], align 8
// CHECK64-NEXT:    [[CONV:%.*]] = bitcast i64* [[FOO_ADDR]] to i32*
// CHECK64-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1]], i1 false, i1 true)
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    [[TMP1:%.*]] = load i32, i32* [[CONV]], align 8
// CHECK64-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP1]], 0
// CHECK64-NEXT:    br i1 [[TOBOOL]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK64:       if.then:
// CHECK64-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [[PRINTF_ARGS_0]], %printf_args.0* [[TMP]], i32 0, i32 0
// CHECK64-NEXT:    store i32 42, i32* [[TMP2]], align 4
// CHECK64-NEXT:    [[TMP3:%.*]] = bitcast %printf_args.0* [[TMP]] to i8*
// CHECK64-NEXT:    [[TMP4:%.*]] = call i32 @vprintf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str2, i64 0, i64 0), i8* [[TMP3]])
// CHECK64-NEXT:    br label [[IF_END]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void
// CHECK64:       if.end:
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB1]], i1 false)
// CHECK64-NEXT:    ret void
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cedcc9_CheckSimple_l11(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[FMT:%.*]] = alloca i8*, align 4
// CHECK32-NEXT:    [[TMP:%.*]] = alloca [[PRINTF_ARGS:%.*]], align 8
// CHECK32-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1:[0-9]+]], i1 false, i1 true)
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0), i8** [[FMT]], align 4
// CHECK32-NEXT:    [[TMP1:%.*]] = load i8*, i8** [[FMT]], align 4
// CHECK32-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [[PRINTF_ARGS]], %printf_args* [[TMP]], i32 0, i32 0
// CHECK32-NEXT:    store i32 1, i32* [[TMP2]], align 4
// CHECK32-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[PRINTF_ARGS]], %printf_args* [[TMP]], i32 0, i32 1
// CHECK32-NEXT:    store i64 2, i64* [[TMP3]], align 8
// CHECK32-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [[PRINTF_ARGS]], %printf_args* [[TMP]], i32 0, i32 2
// CHECK32-NEXT:    store double 3.000000e+00, double* [[TMP4]], align 8
// CHECK32-NEXT:    [[TMP5:%.*]] = bitcast %printf_args* [[TMP]] to i8*
// CHECK32-NEXT:    [[TMP6:%.*]] = call i32 @vprintf(i8* [[TMP1]], i8* [[TMP5]])
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB1]], i1 false)
// CHECK32-NEXT:    ret void
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cedcc9_CheckNoArgs_l21(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1]], i1 false, i1 true)
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    [[TMP1:%.*]] = call i32 @vprintf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str1, i32 0, i32 0), i8* null)
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB1]], i1 false)
// CHECK32-NEXT:    ret void
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cedcc9_CheckAllocaIsInEntryBlock_l31(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[FOO_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[TMP:%.*]] = alloca [[PRINTF_ARGS_0:%.*]], align 8
// CHECK32-NEXT:    store i32 [[FOO:%.*]], i32* [[FOO_ADDR]], align 4
// CHECK32-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1]], i1 false, i1 true)
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    [[TMP1:%.*]] = load i32, i32* [[FOO_ADDR]], align 4
// CHECK32-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP1]], 0
// CHECK32-NEXT:    br i1 [[TOBOOL]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK32:       if.then:
// CHECK32-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [[PRINTF_ARGS_0]], %printf_args.0* [[TMP]], i32 0, i32 0
// CHECK32-NEXT:    store i32 42, i32* [[TMP2]], align 4
// CHECK32-NEXT:    [[TMP3:%.*]] = bitcast %printf_args.0* [[TMP]] to i8*
// CHECK32-NEXT:    [[TMP4:%.*]] = call i32 @vprintf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str2, i32 0, i32 0), i8* [[TMP3]])
// CHECK32-NEXT:    br label [[IF_END]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void
// CHECK32:       if.end:
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB1]], i1 false)
// CHECK32-NEXT:    ret void
//
