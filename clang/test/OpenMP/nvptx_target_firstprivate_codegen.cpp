// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --include-generated-funcs --prefix-filecheck-ir-name _
// Test target codegen - host bc file has to be created first.
// RUN: %clang_cc1 -verify -fopenmp -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm-bc %s -o %t-ppc-host.bc
// RUN: %clang_cc1 -debug-info-kind=limited -verify -fopenmp -x c++ -triple nvptx64-unknown-unknown -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm %s -fopenmp-is-device -fopenmp-host-ir-file-path %t-ppc-host.bc -o - | FileCheck %s --check-prefix CHECK64
// RUN: %clang_cc1 -verify -fopenmp -x c++ -triple i386-unknown-unknown -fopenmp-targets=nvptx-nvidia-cuda -emit-llvm-bc %s -o %t-x86-host.bc
// RUN: %clang_cc1 -debug-info-kind=limited -verify -fopenmp -x c++ -triple nvptx-unknown-unknown -fopenmp-targets=nvptx-nvidia-cuda -emit-llvm %s -fopenmp-is-device -fopenmp-host-ir-file-path %t-x86-host.bc -o - | FileCheck %s --check-prefix CHECK32
// expected-no-diagnostics
#ifndef HEADER
#define HEADER

template <typename tx, typename ty>
struct TT {
  tx X;
  ty Y;
};

int foo(int n, double *ptr) {
  int a = 0;
  short aa = 0;
  float b[10];
  double c[5][10];
  TT<long long, char> d;
  const TT<int, int> e = {n, n};

#pragma omp target firstprivate(a, e) map(tofrom \
                                          : b)
  {
    b[a] = a;
    b[a] += e.X;
  }

#pragma omp target firstprivate(aa, b, c, d)
  {
    aa += 1;
    b[2] = 1.0;
    c[1][2] = 1.0;
    d.X = 1;
    d.Y = 1;
  }

  // make sure that firstprivate variables are generated in all cases and that we use those instances for operations inside the
  // target region

#pragma omp target firstprivate(ptr)
  {
    ptr[0]++;
  }

  return a;
}

template <typename tx>
tx ftemplate(int n) {
  tx a = 0;
  tx b[10];

#pragma omp target firstprivate(a, b)
  {
    a += 1;
    b[2] += 1;
  }

  return a;
}

static int fstatic(int n) {
  int a = 0;
  char aaa = 0;
  int b[10];

#pragma omp target firstprivate(a, aaa, b)
  {
    a += 1;
    aaa += 1;
    b[2] += 1;
  }

  return a;
}

struct S1 {
  double a;

  int r1(int n) {
    int b = n + 1;

#pragma omp target firstprivate(b)
    {
      this->a = (double)b + 1.5;
    }

    return (int)b;
  }

};

int bar(int n, double *ptr) {
  int a = 0;
  a += foo(n, ptr);
  S1 S;
  a += S.r1(n);
  a += fstatic(n);
  a += ftemplate<int>(n);

  return a;
}

// template

#endif
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l25_debug__(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float] addrspace(1)*, align 8
// CHECK64-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK64-NEXT:    [[E_ADDR:%.*]] = alloca %struct.TT*, align 8
// CHECK64-NEXT:    [[TMP:%.*]] = alloca [10 x float]*, align 8
// CHECK64-NEXT:    [[_TMP1:%.*]] = alloca %struct.TT*, align 8
// CHECK64-NEXT:    store [10 x float] addrspace(1)* [[B:%.*]], [10 x float] addrspace(1)** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x float] addrspace(1)** [[B_ADDR]], metadata [[META42:![0-9]+]], metadata !DIExpression()), !dbg [[DBG43:![0-9]+]]
// CHECK64-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META44:![0-9]+]], metadata !DIExpression()), !dbg [[DBG45:![0-9]+]]
// CHECK64-NEXT:    store %struct.TT* [[E:%.*]], %struct.TT** [[E_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT** [[E_ADDR]], metadata [[META46:![0-9]+]], metadata !DIExpression()), !dbg [[DBG47:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x float] addrspace(1)*, [10 x float] addrspace(1)** [[B_ADDR]], align 8, !dbg [[DBG48:![0-9]+]]
// CHECK64-NEXT:    [[TMP1:%.*]] = addrspacecast [10 x float] addrspace(1)* [[TMP0]] to [10 x float]*, !dbg [[DBG48]]
// CHECK64-NEXT:    store [10 x float]* [[TMP1]], [10 x float]** [[TMP]], align 8, !dbg [[DBG48]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load [10 x float]*, [10 x float]** [[TMP]], align 8, !dbg [[DBG48]]
// CHECK64-NEXT:    [[TMP3:%.*]] = load %struct.TT*, %struct.TT** [[E_ADDR]], align 8, !dbg [[DBG48]]
// CHECK64-NEXT:    store %struct.TT* [[TMP3]], %struct.TT** [[_TMP1]], align 8, !dbg [[DBG48]]
// CHECK64-NEXT:    [[TMP4:%.*]] = load %struct.TT*, %struct.TT** [[_TMP1]], align 8, !dbg [[DBG48]]
// CHECK64-NEXT:    [[TMP5:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1:[0-9]+]], i1 false, i1 true), !dbg [[DBG48]]
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP5]], 0, !dbg [[DBG48]]
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG48]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    [[TMP6:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG49:![0-9]+]]
// CHECK64-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP6]] to float, !dbg [[DBG49]]
// CHECK64-NEXT:    [[TMP7:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG51:![0-9]+]]
// CHECK64-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP7]] to i64, !dbg [[DBG52:![0-9]+]]
// CHECK64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x float], [10 x float]* [[TMP2]], i64 0, i64 [[IDXPROM]], !dbg [[DBG52]]
// CHECK64-NEXT:    store float [[CONV]], float* [[ARRAYIDX]], align 4, !dbg [[DBG53:![0-9]+]]
// CHECK64-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_TT:%.*]], %struct.TT* [[TMP4]], i32 0, i32 0, !dbg [[DBG54:![0-9]+]]
// CHECK64-NEXT:    [[TMP8:%.*]] = load i32, i32* [[X]], align 4, !dbg [[DBG54]]
// CHECK64-NEXT:    [[CONV2:%.*]] = sitofp i32 [[TMP8]] to float, !dbg [[DBG55:![0-9]+]]
// CHECK64-NEXT:    [[TMP9:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG56:![0-9]+]]
// CHECK64-NEXT:    [[IDXPROM3:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG57:![0-9]+]]
// CHECK64-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [10 x float], [10 x float]* [[TMP2]], i64 0, i64 [[IDXPROM3]], !dbg [[DBG57]]
// CHECK64-NEXT:    [[TMP10:%.*]] = load float, float* [[ARRAYIDX4]], align 4, !dbg [[DBG58:![0-9]+]]
// CHECK64-NEXT:    [[ADD:%.*]] = fadd float [[TMP10]], [[CONV2]], !dbg [[DBG58]]
// CHECK64-NEXT:    store float [[ADD]], float* [[ARRAYIDX4]], align 4, !dbg [[DBG58]]
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB3:[0-9]+]], i1 false), !dbg [[DBG59:![0-9]+]]
// CHECK64-NEXT:    ret void, !dbg [[DBG60:![0-9]+]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void, !dbg [[DBG48]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l25(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float]*, align 8
// CHECK64-NEXT:    [[A_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    [[E_ADDR:%.*]] = alloca %struct.TT*, align 8
// CHECK64-NEXT:    store [10 x float]* [[B:%.*]], [10 x float]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]** [[B_ADDR]], metadata [[META67:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68:![0-9]+]]
// CHECK64-NEXT:    store i64 [[A:%.*]], i64* [[A_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i64* [[A_ADDR]], metadata [[META69:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68]]
// CHECK64-NEXT:    store %struct.TT* [[E:%.*]], %struct.TT** [[E_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT** [[E_ADDR]], metadata [[META70:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 8, !dbg [[DBG71:![0-9]+]]
// CHECK64-NEXT:    [[CONV:%.*]] = bitcast i64* [[A_ADDR]] to i32*, !dbg [[DBG71]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load %struct.TT*, %struct.TT** [[E_ADDR]], align 8, !dbg [[DBG71]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 8, !dbg [[DBG71]]
// CHECK64-NEXT:    [[TMP3:%.*]] = load i32, i32* [[CONV]], align 8, !dbg [[DBG71]]
// CHECK64-NEXT:    [[TMP4:%.*]] = load %struct.TT*, %struct.TT** [[E_ADDR]], align 8, !dbg [[DBG71]]
// CHECK64-NEXT:    [[TMP5:%.*]] = addrspacecast [10 x float]* [[TMP2]] to [10 x float] addrspace(1)*, !dbg [[DBG71]]
// CHECK64-NEXT:    call void @__omp_offloading_2a_cee46c__Z3fooiPd_l25_debug__([10 x float] addrspace(1)* [[TMP5]], i32 [[TMP3]], %struct.TT* [[TMP4]]) #[[ATTR3:[0-9]+]], !dbg [[DBG71]]
// CHECK64-NEXT:    ret void, !dbg [[DBG71]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l32_debug__(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[AA_ADDR:%.*]] = alloca i16, align 2
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float]*, align 8
// CHECK64-NEXT:    [[C_ADDR:%.*]] = alloca [5 x [10 x double]]*, align 8
// CHECK64-NEXT:    [[D_ADDR:%.*]] = alloca %struct.TT.0*, align 8
// CHECK64-NEXT:    [[TMP:%.*]] = alloca [10 x float]*, align 8
// CHECK64-NEXT:    [[_TMP1:%.*]] = alloca [5 x [10 x double]]*, align 8
// CHECK64-NEXT:    [[_TMP2:%.*]] = alloca %struct.TT.0*, align 8
// CHECK64-NEXT:    [[B3:%.*]] = alloca [10 x float], align 4
// CHECK64-NEXT:    [[C4:%.*]] = alloca [5 x [10 x double]], align 8
// CHECK64-NEXT:    [[D5:%.*]] = alloca [[STRUCT_TT_0:%.*]], align 8
// CHECK64-NEXT:    store i16 [[AA:%.*]], i16* [[AA_ADDR]], align 2
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i16* [[AA_ADDR]], metadata [[META94:![0-9]+]], metadata !DIExpression()), !dbg [[DBG95:![0-9]+]]
// CHECK64-NEXT:    store [10 x float]* [[B:%.*]], [10 x float]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]** [[B_ADDR]], metadata [[META96:![0-9]+]], metadata !DIExpression()), !dbg [[DBG97:![0-9]+]]
// CHECK64-NEXT:    store [5 x [10 x double]]* [[C:%.*]], [5 x [10 x double]]** [[C_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [5 x [10 x double]]** [[C_ADDR]], metadata [[META98:![0-9]+]], metadata !DIExpression()), !dbg [[DBG99:![0-9]+]]
// CHECK64-NEXT:    store %struct.TT.0* [[D:%.*]], %struct.TT.0** [[D_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT.0** [[D_ADDR]], metadata [[META100:![0-9]+]], metadata !DIExpression()), !dbg [[DBG101:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 8, !dbg [[DBG102:![0-9]+]]
// CHECK64-NEXT:    store [10 x float]* [[TMP0]], [10 x float]** [[TMP]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load [10 x float]*, [10 x float]** [[TMP]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[C_ADDR]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    store [5 x [10 x double]]* [[TMP2]], [5 x [10 x double]]** [[_TMP1]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP3:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[_TMP1]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP4:%.*]] = load %struct.TT.0*, %struct.TT.0** [[D_ADDR]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    store %struct.TT.0* [[TMP4]], %struct.TT.0** [[_TMP2]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP5:%.*]] = load %struct.TT.0*, %struct.TT.0** [[_TMP2]], align 8, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB5:[0-9]+]], i1 false, i1 true), !dbg [[DBG102]]
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP6]], 0, !dbg [[DBG102]]
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG102]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]* [[B3]], metadata [[META103:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104:![0-9]+]]
// CHECK64-NEXT:    [[TMP7:%.*]] = bitcast [10 x float]* [[B3]] to i8*, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP8:%.*]] = bitcast [10 x float]* [[TMP1]] to i8*, !dbg [[DBG102]]
// CHECK64-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[TMP7]], i8* align 4 [[TMP8]], i64 40, i1 false), !dbg [[DBG102]]
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [5 x [10 x double]]* [[C4]], metadata [[META105:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104]]
// CHECK64-NEXT:    [[TMP9:%.*]] = bitcast [5 x [10 x double]]* [[C4]] to i8*, !dbg [[DBG102]]
// CHECK64-NEXT:    [[TMP10:%.*]] = bitcast [5 x [10 x double]]* [[TMP3]] to i8*, !dbg [[DBG102]]
// CHECK64-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[TMP9]], i8* align 8 [[TMP10]], i64 400, i1 false), !dbg [[DBG102]]
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT.0* [[D5]], metadata [[META106:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104]]
// CHECK64-NEXT:    [[TMP11:%.*]] = bitcast %struct.TT.0* [[D5]] to i8*, !dbg [[DBG107:![0-9]+]]
// CHECK64-NEXT:    [[TMP12:%.*]] = bitcast %struct.TT.0* [[TMP5]] to i8*, !dbg [[DBG107]]
// CHECK64-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[TMP11]], i8* align 8 [[TMP12]], i64 16, i1 false), !dbg [[DBG107]]
// CHECK64-NEXT:    [[TMP13:%.*]] = load i16, i16* [[AA_ADDR]], align 2, !dbg [[DBG108:![0-9]+]]
// CHECK64-NEXT:    [[CONV:%.*]] = sext i16 [[TMP13]] to i32, !dbg [[DBG108]]
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i32 [[CONV]], 1, !dbg [[DBG108]]
// CHECK64-NEXT:    [[CONV6:%.*]] = trunc i32 [[ADD]] to i16, !dbg [[DBG108]]
// CHECK64-NEXT:    store i16 [[CONV6]], i16* [[AA_ADDR]], align 2, !dbg [[DBG108]]
// CHECK64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x float], [10 x float]* [[B3]], i64 0, i64 2, !dbg [[DBG110:![0-9]+]]
// CHECK64-NEXT:    store float 1.000000e+00, float* [[ARRAYIDX]], align 4, !dbg [[DBG111:![0-9]+]]
// CHECK64-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds [5 x [10 x double]], [5 x [10 x double]]* [[C4]], i64 0, i64 1, !dbg [[DBG112:![0-9]+]]
// CHECK64-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [10 x double], [10 x double]* [[ARRAYIDX7]], i64 0, i64 2, !dbg [[DBG112]]
// CHECK64-NEXT:    store double 1.000000e+00, double* [[ARRAYIDX8]], align 8, !dbg [[DBG113:![0-9]+]]
// CHECK64-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_TT_0]], %struct.TT.0* [[D5]], i32 0, i32 0, !dbg [[DBG114:![0-9]+]]
// CHECK64-NEXT:    store i64 1, i64* [[X]], align 8, !dbg [[DBG115:![0-9]+]]
// CHECK64-NEXT:    [[Y:%.*]] = getelementptr inbounds [[STRUCT_TT_0]], %struct.TT.0* [[D5]], i32 0, i32 1, !dbg [[DBG116:![0-9]+]]
// CHECK64-NEXT:    store i8 1, i8* [[Y]], align 8, !dbg [[DBG117:![0-9]+]]
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB7:[0-9]+]], i1 false), !dbg [[DBG118:![0-9]+]]
// CHECK64-NEXT:    ret void, !dbg [[DBG119:![0-9]+]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void, !dbg [[DBG102]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l32(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[AA_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float]*, align 8
// CHECK64-NEXT:    [[C_ADDR:%.*]] = alloca [5 x [10 x double]]*, align 8
// CHECK64-NEXT:    [[D_ADDR:%.*]] = alloca %struct.TT.0*, align 8
// CHECK64-NEXT:    store i64 [[AA:%.*]], i64* [[AA_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i64* [[AA_ADDR]], metadata [[META125:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126:![0-9]+]]
// CHECK64-NEXT:    store [10 x float]* [[B:%.*]], [10 x float]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]** [[B_ADDR]], metadata [[META127:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126]]
// CHECK64-NEXT:    store [5 x [10 x double]]* [[C:%.*]], [5 x [10 x double]]** [[C_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [5 x [10 x double]]** [[C_ADDR]], metadata [[META128:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126]]
// CHECK64-NEXT:    store %struct.TT.0* [[D:%.*]], %struct.TT.0** [[D_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT.0** [[D_ADDR]], metadata [[META129:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126]]
// CHECK64-NEXT:    [[CONV:%.*]] = bitcast i64* [[AA_ADDR]] to i16*, !dbg [[DBG130:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[C_ADDR]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load %struct.TT.0*, %struct.TT.0** [[D_ADDR]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    [[TMP3:%.*]] = load i16, i16* [[CONV]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    [[TMP4:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    [[TMP5:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[C_ADDR]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    [[TMP6:%.*]] = load %struct.TT.0*, %struct.TT.0** [[D_ADDR]], align 8, !dbg [[DBG130]]
// CHECK64-NEXT:    call void @__omp_offloading_2a_cee46c__Z3fooiPd_l32_debug__(i16 [[TMP3]], [10 x float]* [[TMP4]], [5 x [10 x double]]* [[TMP5]], %struct.TT.0* [[TMP6]]) #[[ATTR3]], !dbg [[DBG130]]
// CHECK64-NEXT:    ret void, !dbg [[DBG130]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l44_debug__(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[PTR_ADDR:%.*]] = alloca double*, align 8
// CHECK64-NEXT:    store double* [[PTR:%.*]], double** [[PTR_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata double** [[PTR_ADDR]], metadata [[META135:![0-9]+]], metadata !DIExpression()), !dbg [[DBG136:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB9:[0-9]+]], i1 false, i1 true), !dbg [[DBG137:![0-9]+]]
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0, !dbg [[DBG137]]
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG137]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    [[TMP1:%.*]] = load double*, double** [[PTR_ADDR]], align 8, !dbg [[DBG138:![0-9]+]]
// CHECK64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, double* [[TMP1]], i64 0, !dbg [[DBG138]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load double, double* [[ARRAYIDX]], align 8, !dbg [[DBG140:![0-9]+]]
// CHECK64-NEXT:    [[INC:%.*]] = fadd double [[TMP2]], 1.000000e+00, !dbg [[DBG140]]
// CHECK64-NEXT:    store double [[INC]], double* [[ARRAYIDX]], align 8, !dbg [[DBG140]]
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB11:[0-9]+]], i1 false), !dbg [[DBG141:![0-9]+]]
// CHECK64-NEXT:    ret void, !dbg [[DBG142:![0-9]+]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void, !dbg [[DBG137]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l44(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[PTR_ADDR:%.*]] = alloca double*, align 8
// CHECK64-NEXT:    store double* [[PTR:%.*]], double** [[PTR_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata double** [[PTR_ADDR]], metadata [[META144:![0-9]+]], metadata !DIExpression()), !dbg [[DBG145:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load double*, double** [[PTR_ADDR]], align 8, !dbg [[DBG146:![0-9]+]]
// CHECK64-NEXT:    call void @__omp_offloading_2a_cee46c__Z3fooiPd_l44_debug__(double* [[TMP0]]) #[[ATTR3]], !dbg [[DBG146]]
// CHECK64-NEXT:    ret void, !dbg [[DBG146]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__ZL7fstatici_l71_debug__(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK64-NEXT:    [[AAA_ADDR:%.*]] = alloca i8, align 1
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 8
// CHECK64-NEXT:    [[TMP:%.*]] = alloca [10 x i32]*, align 8
// CHECK64-NEXT:    [[B1:%.*]] = alloca [10 x i32], align 4
// CHECK64-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META153:![0-9]+]], metadata !DIExpression()), !dbg [[DBG154:![0-9]+]]
// CHECK64-NEXT:    store i8 [[AAA:%.*]], i8* [[AAA_ADDR]], align 1
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i8* [[AAA_ADDR]], metadata [[META155:![0-9]+]], metadata !DIExpression()), !dbg [[DBG156:![0-9]+]]
// CHECK64-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META157:![0-9]+]], metadata !DIExpression()), !dbg [[DBG158:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 8, !dbg [[DBG159:![0-9]+]]
// CHECK64-NEXT:    store [10 x i32]* [[TMP0]], [10 x i32]** [[TMP]], align 8, !dbg [[DBG159]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load [10 x i32]*, [10 x i32]** [[TMP]], align 8, !dbg [[DBG159]]
// CHECK64-NEXT:    [[TMP2:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB13:[0-9]+]], i1 false, i1 true), !dbg [[DBG159]]
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP2]], 0, !dbg [[DBG159]]
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG159]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]* [[B1]], metadata [[META160:![0-9]+]], metadata !DIExpression()), !dbg [[DBG161:![0-9]+]]
// CHECK64-NEXT:    [[TMP3:%.*]] = bitcast [10 x i32]* [[B1]] to i8*, !dbg [[DBG159]]
// CHECK64-NEXT:    [[TMP4:%.*]] = bitcast [10 x i32]* [[TMP1]] to i8*, !dbg [[DBG159]]
// CHECK64-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[TMP3]], i8* align 4 [[TMP4]], i64 40, i1 false), !dbg [[DBG159]]
// CHECK64-NEXT:    [[TMP5:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG162:![0-9]+]]
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP5]], 1, !dbg [[DBG162]]
// CHECK64-NEXT:    store i32 [[ADD]], i32* [[A_ADDR]], align 4, !dbg [[DBG162]]
// CHECK64-NEXT:    [[TMP6:%.*]] = load i8, i8* [[AAA_ADDR]], align 1, !dbg [[DBG164:![0-9]+]]
// CHECK64-NEXT:    [[CONV:%.*]] = sext i8 [[TMP6]] to i32, !dbg [[DBG164]]
// CHECK64-NEXT:    [[ADD2:%.*]] = add nsw i32 [[CONV]], 1, !dbg [[DBG164]]
// CHECK64-NEXT:    [[CONV3:%.*]] = trunc i32 [[ADD2]] to i8, !dbg [[DBG164]]
// CHECK64-NEXT:    store i8 [[CONV3]], i8* [[AAA_ADDR]], align 1, !dbg [[DBG164]]
// CHECK64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[B1]], i64 0, i64 2, !dbg [[DBG165:![0-9]+]]
// CHECK64-NEXT:    [[TMP7:%.*]] = load i32, i32* [[ARRAYIDX]], align 4, !dbg [[DBG166:![0-9]+]]
// CHECK64-NEXT:    [[ADD4:%.*]] = add nsw i32 [[TMP7]], 1, !dbg [[DBG166]]
// CHECK64-NEXT:    store i32 [[ADD4]], i32* [[ARRAYIDX]], align 4, !dbg [[DBG166]]
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB15:[0-9]+]], i1 false), !dbg [[DBG167:![0-9]+]]
// CHECK64-NEXT:    ret void, !dbg [[DBG168:![0-9]+]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void, !dbg [[DBG159]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__ZL7fstatici_l71(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[A_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    [[AAA_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 8
// CHECK64-NEXT:    store i64 [[A:%.*]], i64* [[A_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i64* [[A_ADDR]], metadata [[META173:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174:![0-9]+]]
// CHECK64-NEXT:    store i64 [[AAA:%.*]], i64* [[AAA_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i64* [[AAA_ADDR]], metadata [[META175:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174]]
// CHECK64-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META176:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174]]
// CHECK64-NEXT:    [[CONV:%.*]] = bitcast i64* [[A_ADDR]] to i32*, !dbg [[DBG177:![0-9]+]]
// CHECK64-NEXT:    [[CONV1:%.*]] = bitcast i64* [[AAA_ADDR]] to i8*, !dbg [[DBG177]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 8, !dbg [[DBG177]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load i32, i32* [[CONV]], align 8, !dbg [[DBG177]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load i8, i8* [[CONV1]], align 8, !dbg [[DBG177]]
// CHECK64-NEXT:    [[TMP3:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 8, !dbg [[DBG177]]
// CHECK64-NEXT:    call void @__omp_offloading_2a_cee46c__ZL7fstatici_l71_debug__(i32 [[TMP1]], i8 [[TMP2]], [10 x i32]* [[TMP3]]) #[[ATTR3]], !dbg [[DBG177]]
// CHECK64-NEXT:    ret void, !dbg [[DBG177]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__ZN2S12r1Ei_l87_debug__(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.S1*, align 8
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
// CHECK64-NEXT:    store %struct.S1* [[THIS:%.*]], %struct.S1** [[THIS_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.S1** [[THIS_ADDR]], metadata [[META189:![0-9]+]], metadata !DIExpression()), !dbg [[DBG190:![0-9]+]]
// CHECK64-NEXT:    store i32 [[B:%.*]], i32* [[B_ADDR]], align 4
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i32* [[B_ADDR]], metadata [[META191:![0-9]+]], metadata !DIExpression()), !dbg [[DBG192:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load %struct.S1*, %struct.S1** [[THIS_ADDR]], align 8, !dbg [[DBG193:![0-9]+]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB17:[0-9]+]], i1 false, i1 true), !dbg [[DBG193]]
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP1]], 0, !dbg [[DBG193]]
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG193]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    [[TMP2:%.*]] = load i32, i32* [[B_ADDR]], align 4, !dbg [[DBG194:![0-9]+]]
// CHECK64-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP2]] to double, !dbg [[DBG194]]
// CHECK64-NEXT:    [[ADD:%.*]] = fadd double [[CONV]], 1.500000e+00, !dbg [[DBG196:![0-9]+]]
// CHECK64-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S1:%.*]], %struct.S1* [[TMP0]], i32 0, i32 0, !dbg [[DBG197:![0-9]+]]
// CHECK64-NEXT:    store double [[ADD]], double* [[A]], align 8, !dbg [[DBG198:![0-9]+]]
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB19:[0-9]+]], i1 false), !dbg [[DBG199:![0-9]+]]
// CHECK64-NEXT:    ret void, !dbg [[DBG200:![0-9]+]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void, !dbg [[DBG193]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__ZN2S12r1Ei_l87(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.S1*, align 8
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    store %struct.S1* [[THIS:%.*]], %struct.S1** [[THIS_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata %struct.S1** [[THIS_ADDR]], metadata [[META204:![0-9]+]], metadata !DIExpression()), !dbg [[DBG205:![0-9]+]]
// CHECK64-NEXT:    store i64 [[B:%.*]], i64* [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i64* [[B_ADDR]], metadata [[META206:![0-9]+]], metadata !DIExpression()), !dbg [[DBG205]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load %struct.S1*, %struct.S1** [[THIS_ADDR]], align 8, !dbg [[DBG207:![0-9]+]]
// CHECK64-NEXT:    [[CONV:%.*]] = bitcast i64* [[B_ADDR]] to i32*, !dbg [[DBG207]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load %struct.S1*, %struct.S1** [[THIS_ADDR]], align 8, !dbg [[DBG207]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load i32, i32* [[CONV]], align 8, !dbg [[DBG207]]
// CHECK64-NEXT:    call void @__omp_offloading_2a_cee46c__ZN2S12r1Ei_l87_debug__(%struct.S1* [[TMP1]], i32 [[TMP2]]) #[[ATTR3]], !dbg [[DBG207]]
// CHECK64-NEXT:    ret void, !dbg [[DBG207]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z9ftemplateIiET_i_l57_debug__(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 8
// CHECK64-NEXT:    [[TMP:%.*]] = alloca [10 x i32]*, align 8
// CHECK64-NEXT:    [[B1:%.*]] = alloca [10 x i32], align 4
// CHECK64-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META211:![0-9]+]], metadata !DIExpression()), !dbg [[DBG212:![0-9]+]]
// CHECK64-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META213:![0-9]+]], metadata !DIExpression()), !dbg [[DBG214:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 8, !dbg [[DBG215:![0-9]+]]
// CHECK64-NEXT:    store [10 x i32]* [[TMP0]], [10 x i32]** [[TMP]], align 8, !dbg [[DBG215]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load [10 x i32]*, [10 x i32]** [[TMP]], align 8, !dbg [[DBG215]]
// CHECK64-NEXT:    [[TMP2:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB21:[0-9]+]], i1 false, i1 true), !dbg [[DBG215]]
// CHECK64-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP2]], 0, !dbg [[DBG215]]
// CHECK64-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG215]]
// CHECK64:       user_code.entry:
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]* [[B1]], metadata [[META216:![0-9]+]], metadata !DIExpression()), !dbg [[DBG217:![0-9]+]]
// CHECK64-NEXT:    [[TMP3:%.*]] = bitcast [10 x i32]* [[B1]] to i8*, !dbg [[DBG215]]
// CHECK64-NEXT:    [[TMP4:%.*]] = bitcast [10 x i32]* [[TMP1]] to i8*, !dbg [[DBG215]]
// CHECK64-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[TMP3]], i8* align 4 [[TMP4]], i64 40, i1 false), !dbg [[DBG215]]
// CHECK64-NEXT:    [[TMP5:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG218:![0-9]+]]
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP5]], 1, !dbg [[DBG218]]
// CHECK64-NEXT:    store i32 [[ADD]], i32* [[A_ADDR]], align 4, !dbg [[DBG218]]
// CHECK64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[B1]], i64 0, i64 2, !dbg [[DBG220:![0-9]+]]
// CHECK64-NEXT:    [[TMP6:%.*]] = load i32, i32* [[ARRAYIDX]], align 4, !dbg [[DBG221:![0-9]+]]
// CHECK64-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP6]], 1, !dbg [[DBG221]]
// CHECK64-NEXT:    store i32 [[ADD2]], i32* [[ARRAYIDX]], align 4, !dbg [[DBG221]]
// CHECK64-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB23:[0-9]+]], i1 false), !dbg [[DBG222:![0-9]+]]
// CHECK64-NEXT:    ret void, !dbg [[DBG223:![0-9]+]]
// CHECK64:       worker.exit:
// CHECK64-NEXT:    ret void, !dbg [[DBG215]]
//
//
// CHECK64-LABEL: @__omp_offloading_2a_cee46c__Z9ftemplateIiET_i_l57(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[A_ADDR:%.*]] = alloca i64, align 8
// CHECK64-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 8
// CHECK64-NEXT:    store i64 [[A:%.*]], i64* [[A_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata i64* [[A_ADDR]], metadata [[META227:![0-9]+]], metadata !DIExpression()), !dbg [[DBG228:![0-9]+]]
// CHECK64-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 8
// CHECK64-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META229:![0-9]+]], metadata !DIExpression()), !dbg [[DBG228]]
// CHECK64-NEXT:    [[CONV:%.*]] = bitcast i64* [[A_ADDR]] to i32*, !dbg [[DBG230:![0-9]+]]
// CHECK64-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 8, !dbg [[DBG230]]
// CHECK64-NEXT:    [[TMP1:%.*]] = load i32, i32* [[CONV]], align 8, !dbg [[DBG230]]
// CHECK64-NEXT:    [[TMP2:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 8, !dbg [[DBG230]]
// CHECK64-NEXT:    call void @__omp_offloading_2a_cee46c__Z9ftemplateIiET_i_l57_debug__(i32 [[TMP1]], [10 x i32]* [[TMP2]]) #[[ATTR3]], !dbg [[DBG230]]
// CHECK64-NEXT:    ret void, !dbg [[DBG230]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l25_debug__(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float] addrspace(1)*, align 4
// CHECK32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[E_ADDR:%.*]] = alloca %struct.TT*, align 4
// CHECK32-NEXT:    [[TMP:%.*]] = alloca [10 x float]*, align 4
// CHECK32-NEXT:    [[_TMP1:%.*]] = alloca %struct.TT*, align 4
// CHECK32-NEXT:    store [10 x float] addrspace(1)* [[B:%.*]], [10 x float] addrspace(1)** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x float] addrspace(1)** [[B_ADDR]], metadata [[META42:![0-9]+]], metadata !DIExpression()), !dbg [[DBG43:![0-9]+]]
// CHECK32-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META44:![0-9]+]], metadata !DIExpression()), !dbg [[DBG45:![0-9]+]]
// CHECK32-NEXT:    store %struct.TT* [[E:%.*]], %struct.TT** [[E_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT** [[E_ADDR]], metadata [[META46:![0-9]+]], metadata !DIExpression()), !dbg [[DBG47:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x float] addrspace(1)*, [10 x float] addrspace(1)** [[B_ADDR]], align 4, !dbg [[DBG48:![0-9]+]]
// CHECK32-NEXT:    [[TMP1:%.*]] = addrspacecast [10 x float] addrspace(1)* [[TMP0]] to [10 x float]*, !dbg [[DBG48]]
// CHECK32-NEXT:    store [10 x float]* [[TMP1]], [10 x float]** [[TMP]], align 4, !dbg [[DBG48]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load [10 x float]*, [10 x float]** [[TMP]], align 4, !dbg [[DBG48]]
// CHECK32-NEXT:    [[TMP3:%.*]] = load %struct.TT*, %struct.TT** [[E_ADDR]], align 4, !dbg [[DBG48]]
// CHECK32-NEXT:    store %struct.TT* [[TMP3]], %struct.TT** [[_TMP1]], align 4, !dbg [[DBG48]]
// CHECK32-NEXT:    [[TMP4:%.*]] = load %struct.TT*, %struct.TT** [[_TMP1]], align 4, !dbg [[DBG48]]
// CHECK32-NEXT:    [[TMP5:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB1:[0-9]+]], i1 false, i1 true), !dbg [[DBG48]]
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP5]], 0, !dbg [[DBG48]]
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG48]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    [[TMP6:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG49:![0-9]+]]
// CHECK32-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP6]] to float, !dbg [[DBG49]]
// CHECK32-NEXT:    [[TMP7:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG51:![0-9]+]]
// CHECK32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x float], [10 x float]* [[TMP2]], i32 0, i32 [[TMP7]], !dbg [[DBG52:![0-9]+]]
// CHECK32-NEXT:    store float [[CONV]], float* [[ARRAYIDX]], align 4, !dbg [[DBG53:![0-9]+]]
// CHECK32-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_TT:%.*]], %struct.TT* [[TMP4]], i32 0, i32 0, !dbg [[DBG54:![0-9]+]]
// CHECK32-NEXT:    [[TMP8:%.*]] = load i32, i32* [[X]], align 4, !dbg [[DBG54]]
// CHECK32-NEXT:    [[CONV2:%.*]] = sitofp i32 [[TMP8]] to float, !dbg [[DBG55:![0-9]+]]
// CHECK32-NEXT:    [[TMP9:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG56:![0-9]+]]
// CHECK32-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds [10 x float], [10 x float]* [[TMP2]], i32 0, i32 [[TMP9]], !dbg [[DBG57:![0-9]+]]
// CHECK32-NEXT:    [[TMP10:%.*]] = load float, float* [[ARRAYIDX3]], align 4, !dbg [[DBG58:![0-9]+]]
// CHECK32-NEXT:    [[ADD:%.*]] = fadd float [[TMP10]], [[CONV2]], !dbg [[DBG58]]
// CHECK32-NEXT:    store float [[ADD]], float* [[ARRAYIDX3]], align 4, !dbg [[DBG58]]
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB3:[0-9]+]], i1 false), !dbg [[DBG59:![0-9]+]]
// CHECK32-NEXT:    ret void, !dbg [[DBG60:![0-9]+]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void, !dbg [[DBG48]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l25(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float]*, align 4
// CHECK32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[E_ADDR:%.*]] = alloca %struct.TT*, align 4
// CHECK32-NEXT:    store [10 x float]* [[B:%.*]], [10 x float]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]** [[B_ADDR]], metadata [[META67:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68:![0-9]+]]
// CHECK32-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META69:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68]]
// CHECK32-NEXT:    store %struct.TT* [[E:%.*]], %struct.TT** [[E_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT** [[E_ADDR]], metadata [[META70:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 4, !dbg [[DBG71:![0-9]+]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load %struct.TT*, %struct.TT** [[E_ADDR]], align 4, !dbg [[DBG71]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 4, !dbg [[DBG71]]
// CHECK32-NEXT:    [[TMP3:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG71]]
// CHECK32-NEXT:    [[TMP4:%.*]] = load %struct.TT*, %struct.TT** [[E_ADDR]], align 4, !dbg [[DBG71]]
// CHECK32-NEXT:    [[TMP5:%.*]] = addrspacecast [10 x float]* [[TMP2]] to [10 x float] addrspace(1)*, !dbg [[DBG71]]
// CHECK32-NEXT:    call void @__omp_offloading_2a_cee46c__Z3fooiPd_l25_debug__([10 x float] addrspace(1)* [[TMP5]], i32 [[TMP3]], %struct.TT* [[TMP4]]) #[[ATTR3:[0-9]+]], !dbg [[DBG71]]
// CHECK32-NEXT:    ret void, !dbg [[DBG71]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l32_debug__(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[AA_ADDR:%.*]] = alloca i16, align 2
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float]*, align 4
// CHECK32-NEXT:    [[C_ADDR:%.*]] = alloca [5 x [10 x double]]*, align 4
// CHECK32-NEXT:    [[D_ADDR:%.*]] = alloca %struct.TT.0*, align 4
// CHECK32-NEXT:    [[TMP:%.*]] = alloca [10 x float]*, align 4
// CHECK32-NEXT:    [[_TMP1:%.*]] = alloca [5 x [10 x double]]*, align 4
// CHECK32-NEXT:    [[_TMP2:%.*]] = alloca %struct.TT.0*, align 4
// CHECK32-NEXT:    [[B3:%.*]] = alloca [10 x float], align 4
// CHECK32-NEXT:    [[C4:%.*]] = alloca [5 x [10 x double]], align 8
// CHECK32-NEXT:    [[D5:%.*]] = alloca [[STRUCT_TT_0:%.*]], align 8
// CHECK32-NEXT:    store i16 [[AA:%.*]], i16* [[AA_ADDR]], align 2
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i16* [[AA_ADDR]], metadata [[META94:![0-9]+]], metadata !DIExpression()), !dbg [[DBG95:![0-9]+]]
// CHECK32-NEXT:    store [10 x float]* [[B:%.*]], [10 x float]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]** [[B_ADDR]], metadata [[META96:![0-9]+]], metadata !DIExpression()), !dbg [[DBG97:![0-9]+]]
// CHECK32-NEXT:    store [5 x [10 x double]]* [[C:%.*]], [5 x [10 x double]]** [[C_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [5 x [10 x double]]** [[C_ADDR]], metadata [[META98:![0-9]+]], metadata !DIExpression()), !dbg [[DBG99:![0-9]+]]
// CHECK32-NEXT:    store %struct.TT.0* [[D:%.*]], %struct.TT.0** [[D_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT.0** [[D_ADDR]], metadata [[META100:![0-9]+]], metadata !DIExpression()), !dbg [[DBG101:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 4, !dbg [[DBG102:![0-9]+]]
// CHECK32-NEXT:    store [10 x float]* [[TMP0]], [10 x float]** [[TMP]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load [10 x float]*, [10 x float]** [[TMP]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[C_ADDR]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    store [5 x [10 x double]]* [[TMP2]], [5 x [10 x double]]** [[_TMP1]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP3:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[_TMP1]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP4:%.*]] = load %struct.TT.0*, %struct.TT.0** [[D_ADDR]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    store %struct.TT.0* [[TMP4]], %struct.TT.0** [[_TMP2]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP5:%.*]] = load %struct.TT.0*, %struct.TT.0** [[_TMP2]], align 4, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB5:[0-9]+]], i1 false, i1 true), !dbg [[DBG102]]
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP6]], 0, !dbg [[DBG102]]
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG102]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]* [[B3]], metadata [[META103:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104:![0-9]+]]
// CHECK32-NEXT:    [[TMP7:%.*]] = bitcast [10 x float]* [[B3]] to i8*, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP8:%.*]] = bitcast [10 x float]* [[TMP1]] to i8*, !dbg [[DBG102]]
// CHECK32-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 [[TMP7]], i8* align 4 [[TMP8]], i32 40, i1 false), !dbg [[DBG102]]
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [5 x [10 x double]]* [[C4]], metadata [[META105:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104]]
// CHECK32-NEXT:    [[TMP9:%.*]] = bitcast [5 x [10 x double]]* [[C4]] to i8*, !dbg [[DBG102]]
// CHECK32-NEXT:    [[TMP10:%.*]] = bitcast [5 x [10 x double]]* [[TMP3]] to i8*, !dbg [[DBG102]]
// CHECK32-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 [[TMP9]], i8* align 8 [[TMP10]], i32 400, i1 false), !dbg [[DBG102]]
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT.0* [[D5]], metadata [[META106:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104]]
// CHECK32-NEXT:    [[TMP11:%.*]] = bitcast %struct.TT.0* [[D5]] to i8*, !dbg [[DBG107:![0-9]+]]
// CHECK32-NEXT:    [[TMP12:%.*]] = bitcast %struct.TT.0* [[TMP5]] to i8*, !dbg [[DBG107]]
// CHECK32-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 [[TMP11]], i8* align 8 [[TMP12]], i32 16, i1 false), !dbg [[DBG107]]
// CHECK32-NEXT:    [[TMP13:%.*]] = load i16, i16* [[AA_ADDR]], align 2, !dbg [[DBG108:![0-9]+]]
// CHECK32-NEXT:    [[CONV:%.*]] = sext i16 [[TMP13]] to i32, !dbg [[DBG108]]
// CHECK32-NEXT:    [[ADD:%.*]] = add nsw i32 [[CONV]], 1, !dbg [[DBG108]]
// CHECK32-NEXT:    [[CONV6:%.*]] = trunc i32 [[ADD]] to i16, !dbg [[DBG108]]
// CHECK32-NEXT:    store i16 [[CONV6]], i16* [[AA_ADDR]], align 2, !dbg [[DBG108]]
// CHECK32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x float], [10 x float]* [[B3]], i32 0, i32 2, !dbg [[DBG110:![0-9]+]]
// CHECK32-NEXT:    store float 1.000000e+00, float* [[ARRAYIDX]], align 4, !dbg [[DBG111:![0-9]+]]
// CHECK32-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds [5 x [10 x double]], [5 x [10 x double]]* [[C4]], i32 0, i32 1, !dbg [[DBG112:![0-9]+]]
// CHECK32-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [10 x double], [10 x double]* [[ARRAYIDX7]], i32 0, i32 2, !dbg [[DBG112]]
// CHECK32-NEXT:    store double 1.000000e+00, double* [[ARRAYIDX8]], align 8, !dbg [[DBG113:![0-9]+]]
// CHECK32-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_TT_0]], %struct.TT.0* [[D5]], i32 0, i32 0, !dbg [[DBG114:![0-9]+]]
// CHECK32-NEXT:    store i64 1, i64* [[X]], align 8, !dbg [[DBG115:![0-9]+]]
// CHECK32-NEXT:    [[Y:%.*]] = getelementptr inbounds [[STRUCT_TT_0]], %struct.TT.0* [[D5]], i32 0, i32 1, !dbg [[DBG116:![0-9]+]]
// CHECK32-NEXT:    store i8 1, i8* [[Y]], align 8, !dbg [[DBG117:![0-9]+]]
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB7:[0-9]+]], i1 false), !dbg [[DBG118:![0-9]+]]
// CHECK32-NEXT:    ret void, !dbg [[DBG119:![0-9]+]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void, !dbg [[DBG102]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l32(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[AA_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x float]*, align 4
// CHECK32-NEXT:    [[C_ADDR:%.*]] = alloca [5 x [10 x double]]*, align 4
// CHECK32-NEXT:    [[D_ADDR:%.*]] = alloca %struct.TT.0*, align 4
// CHECK32-NEXT:    store i32 [[AA:%.*]], i32* [[AA_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[AA_ADDR]], metadata [[META125:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126:![0-9]+]]
// CHECK32-NEXT:    store [10 x float]* [[B:%.*]], [10 x float]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x float]** [[B_ADDR]], metadata [[META127:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126]]
// CHECK32-NEXT:    store [5 x [10 x double]]* [[C:%.*]], [5 x [10 x double]]** [[C_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [5 x [10 x double]]** [[C_ADDR]], metadata [[META128:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126]]
// CHECK32-NEXT:    store %struct.TT.0* [[D:%.*]], %struct.TT.0** [[D_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.TT.0** [[D_ADDR]], metadata [[META129:![0-9]+]], metadata !DIExpression()), !dbg [[DBG126]]
// CHECK32-NEXT:    [[CONV:%.*]] = bitcast i32* [[AA_ADDR]] to i16*, !dbg [[DBG130:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[C_ADDR]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load %struct.TT.0*, %struct.TT.0** [[D_ADDR]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    [[TMP3:%.*]] = load i16, i16* [[CONV]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    [[TMP4:%.*]] = load [10 x float]*, [10 x float]** [[B_ADDR]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    [[TMP5:%.*]] = load [5 x [10 x double]]*, [5 x [10 x double]]** [[C_ADDR]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    [[TMP6:%.*]] = load %struct.TT.0*, %struct.TT.0** [[D_ADDR]], align 4, !dbg [[DBG130]]
// CHECK32-NEXT:    call void @__omp_offloading_2a_cee46c__Z3fooiPd_l32_debug__(i16 [[TMP3]], [10 x float]* [[TMP4]], [5 x [10 x double]]* [[TMP5]], %struct.TT.0* [[TMP6]]) #[[ATTR3]], !dbg [[DBG130]]
// CHECK32-NEXT:    ret void, !dbg [[DBG130]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l44_debug__(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[PTR_ADDR:%.*]] = alloca double*, align 4
// CHECK32-NEXT:    store double* [[PTR:%.*]], double** [[PTR_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata double** [[PTR_ADDR]], metadata [[META135:![0-9]+]], metadata !DIExpression()), !dbg [[DBG136:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB9:[0-9]+]], i1 false, i1 true), !dbg [[DBG137:![0-9]+]]
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP0]], 0, !dbg [[DBG137]]
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG137]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    [[TMP1:%.*]] = load double*, double** [[PTR_ADDR]], align 4, !dbg [[DBG138:![0-9]+]]
// CHECK32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, double* [[TMP1]], i32 0, !dbg [[DBG138]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load double, double* [[ARRAYIDX]], align 8, !dbg [[DBG140:![0-9]+]]
// CHECK32-NEXT:    [[INC:%.*]] = fadd double [[TMP2]], 1.000000e+00, !dbg [[DBG140]]
// CHECK32-NEXT:    store double [[INC]], double* [[ARRAYIDX]], align 8, !dbg [[DBG140]]
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB11:[0-9]+]], i1 false), !dbg [[DBG141:![0-9]+]]
// CHECK32-NEXT:    ret void, !dbg [[DBG142:![0-9]+]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void, !dbg [[DBG137]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z3fooiPd_l44(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[PTR_ADDR:%.*]] = alloca double*, align 4
// CHECK32-NEXT:    store double* [[PTR:%.*]], double** [[PTR_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata double** [[PTR_ADDR]], metadata [[META144:![0-9]+]], metadata !DIExpression()), !dbg [[DBG145:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load double*, double** [[PTR_ADDR]], align 4, !dbg [[DBG146:![0-9]+]]
// CHECK32-NEXT:    call void @__omp_offloading_2a_cee46c__Z3fooiPd_l44_debug__(double* [[TMP0]]) #[[ATTR3]], !dbg [[DBG146]]
// CHECK32-NEXT:    ret void, !dbg [[DBG146]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__ZL7fstatici_l71_debug__(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[AAA_ADDR:%.*]] = alloca i8, align 1
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 4
// CHECK32-NEXT:    [[TMP:%.*]] = alloca [10 x i32]*, align 4
// CHECK32-NEXT:    [[B1:%.*]] = alloca [10 x i32], align 4
// CHECK32-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META153:![0-9]+]], metadata !DIExpression()), !dbg [[DBG154:![0-9]+]]
// CHECK32-NEXT:    store i8 [[AAA:%.*]], i8* [[AAA_ADDR]], align 1
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i8* [[AAA_ADDR]], metadata [[META155:![0-9]+]], metadata !DIExpression()), !dbg [[DBG156:![0-9]+]]
// CHECK32-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META157:![0-9]+]], metadata !DIExpression()), !dbg [[DBG158:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 4, !dbg [[DBG159:![0-9]+]]
// CHECK32-NEXT:    store [10 x i32]* [[TMP0]], [10 x i32]** [[TMP]], align 4, !dbg [[DBG159]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load [10 x i32]*, [10 x i32]** [[TMP]], align 4, !dbg [[DBG159]]
// CHECK32-NEXT:    [[TMP2:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB13:[0-9]+]], i1 false, i1 true), !dbg [[DBG159]]
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP2]], 0, !dbg [[DBG159]]
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG159]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]* [[B1]], metadata [[META160:![0-9]+]], metadata !DIExpression()), !dbg [[DBG161:![0-9]+]]
// CHECK32-NEXT:    [[TMP3:%.*]] = bitcast [10 x i32]* [[B1]] to i8*, !dbg [[DBG159]]
// CHECK32-NEXT:    [[TMP4:%.*]] = bitcast [10 x i32]* [[TMP1]] to i8*, !dbg [[DBG159]]
// CHECK32-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 [[TMP3]], i8* align 4 [[TMP4]], i32 40, i1 false), !dbg [[DBG159]]
// CHECK32-NEXT:    [[TMP5:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG162:![0-9]+]]
// CHECK32-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP5]], 1, !dbg [[DBG162]]
// CHECK32-NEXT:    store i32 [[ADD]], i32* [[A_ADDR]], align 4, !dbg [[DBG162]]
// CHECK32-NEXT:    [[TMP6:%.*]] = load i8, i8* [[AAA_ADDR]], align 1, !dbg [[DBG164:![0-9]+]]
// CHECK32-NEXT:    [[CONV:%.*]] = sext i8 [[TMP6]] to i32, !dbg [[DBG164]]
// CHECK32-NEXT:    [[ADD2:%.*]] = add nsw i32 [[CONV]], 1, !dbg [[DBG164]]
// CHECK32-NEXT:    [[CONV3:%.*]] = trunc i32 [[ADD2]] to i8, !dbg [[DBG164]]
// CHECK32-NEXT:    store i8 [[CONV3]], i8* [[AAA_ADDR]], align 1, !dbg [[DBG164]]
// CHECK32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[B1]], i32 0, i32 2, !dbg [[DBG165:![0-9]+]]
// CHECK32-NEXT:    [[TMP7:%.*]] = load i32, i32* [[ARRAYIDX]], align 4, !dbg [[DBG166:![0-9]+]]
// CHECK32-NEXT:    [[ADD4:%.*]] = add nsw i32 [[TMP7]], 1, !dbg [[DBG166]]
// CHECK32-NEXT:    store i32 [[ADD4]], i32* [[ARRAYIDX]], align 4, !dbg [[DBG166]]
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB15:[0-9]+]], i1 false), !dbg [[DBG167:![0-9]+]]
// CHECK32-NEXT:    ret void, !dbg [[DBG168:![0-9]+]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void, !dbg [[DBG159]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__ZL7fstatici_l71(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[AAA_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 4
// CHECK32-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META173:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174:![0-9]+]]
// CHECK32-NEXT:    store i32 [[AAA:%.*]], i32* [[AAA_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[AAA_ADDR]], metadata [[META175:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174]]
// CHECK32-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META176:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174]]
// CHECK32-NEXT:    [[CONV:%.*]] = bitcast i32* [[AAA_ADDR]] to i8*, !dbg [[DBG177:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 4, !dbg [[DBG177]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG177]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load i8, i8* [[CONV]], align 4, !dbg [[DBG177]]
// CHECK32-NEXT:    [[TMP3:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 4, !dbg [[DBG177]]
// CHECK32-NEXT:    call void @__omp_offloading_2a_cee46c__ZL7fstatici_l71_debug__(i32 [[TMP1]], i8 [[TMP2]], [10 x i32]* [[TMP3]]) #[[ATTR3]], !dbg [[DBG177]]
// CHECK32-NEXT:    ret void, !dbg [[DBG177]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__ZN2S12r1Ei_l87_debug__(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.S1*, align 4
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    store %struct.S1* [[THIS:%.*]], %struct.S1** [[THIS_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.S1** [[THIS_ADDR]], metadata [[META189:![0-9]+]], metadata !DIExpression()), !dbg [[DBG190:![0-9]+]]
// CHECK32-NEXT:    store i32 [[B:%.*]], i32* [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[B_ADDR]], metadata [[META191:![0-9]+]], metadata !DIExpression()), !dbg [[DBG192:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load %struct.S1*, %struct.S1** [[THIS_ADDR]], align 4, !dbg [[DBG193:![0-9]+]]
// CHECK32-NEXT:    [[TMP1:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB17:[0-9]+]], i1 false, i1 true), !dbg [[DBG193]]
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP1]], 0, !dbg [[DBG193]]
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG193]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    [[TMP2:%.*]] = load i32, i32* [[B_ADDR]], align 4, !dbg [[DBG194:![0-9]+]]
// CHECK32-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP2]] to double, !dbg [[DBG194]]
// CHECK32-NEXT:    [[ADD:%.*]] = fadd double [[CONV]], 1.500000e+00, !dbg [[DBG196:![0-9]+]]
// CHECK32-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S1:%.*]], %struct.S1* [[TMP0]], i32 0, i32 0, !dbg [[DBG197:![0-9]+]]
// CHECK32-NEXT:    store double [[ADD]], double* [[A]], align 8, !dbg [[DBG198:![0-9]+]]
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB19:[0-9]+]], i1 false), !dbg [[DBG199:![0-9]+]]
// CHECK32-NEXT:    ret void, !dbg [[DBG200:![0-9]+]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void, !dbg [[DBG193]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__ZN2S12r1Ei_l87(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.S1*, align 4
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    store %struct.S1* [[THIS:%.*]], %struct.S1** [[THIS_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata %struct.S1** [[THIS_ADDR]], metadata [[META204:![0-9]+]], metadata !DIExpression()), !dbg [[DBG205:![0-9]+]]
// CHECK32-NEXT:    store i32 [[B:%.*]], i32* [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[B_ADDR]], metadata [[META206:![0-9]+]], metadata !DIExpression()), !dbg [[DBG205]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load %struct.S1*, %struct.S1** [[THIS_ADDR]], align 4, !dbg [[DBG207:![0-9]+]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load %struct.S1*, %struct.S1** [[THIS_ADDR]], align 4, !dbg [[DBG207]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load i32, i32* [[B_ADDR]], align 4, !dbg [[DBG207]]
// CHECK32-NEXT:    call void @__omp_offloading_2a_cee46c__ZN2S12r1Ei_l87_debug__(%struct.S1* [[TMP1]], i32 [[TMP2]]) #[[ATTR3]], !dbg [[DBG207]]
// CHECK32-NEXT:    ret void, !dbg [[DBG207]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z9ftemplateIiET_i_l57_debug__(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 4
// CHECK32-NEXT:    [[TMP:%.*]] = alloca [10 x i32]*, align 4
// CHECK32-NEXT:    [[B1:%.*]] = alloca [10 x i32], align 4
// CHECK32-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META211:![0-9]+]], metadata !DIExpression()), !dbg [[DBG212:![0-9]+]]
// CHECK32-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META213:![0-9]+]], metadata !DIExpression()), !dbg [[DBG214:![0-9]+]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 4, !dbg [[DBG215:![0-9]+]]
// CHECK32-NEXT:    store [10 x i32]* [[TMP0]], [10 x i32]** [[TMP]], align 4, !dbg [[DBG215]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load [10 x i32]*, [10 x i32]** [[TMP]], align 4, !dbg [[DBG215]]
// CHECK32-NEXT:    [[TMP2:%.*]] = call i32 @__kmpc_target_init(%struct.ident_t* @[[GLOB21:[0-9]+]], i1 false, i1 true), !dbg [[DBG215]]
// CHECK32-NEXT:    [[EXEC_USER_CODE:%.*]] = icmp eq i32 [[TMP2]], 0, !dbg [[DBG215]]
// CHECK32-NEXT:    br i1 [[EXEC_USER_CODE]], label [[USER_CODE_ENTRY:%.*]], label [[WORKER_EXIT:%.*]], !dbg [[DBG215]]
// CHECK32:       user_code.entry:
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]* [[B1]], metadata [[META216:![0-9]+]], metadata !DIExpression()), !dbg [[DBG217:![0-9]+]]
// CHECK32-NEXT:    [[TMP3:%.*]] = bitcast [10 x i32]* [[B1]] to i8*, !dbg [[DBG215]]
// CHECK32-NEXT:    [[TMP4:%.*]] = bitcast [10 x i32]* [[TMP1]] to i8*, !dbg [[DBG215]]
// CHECK32-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 [[TMP3]], i8* align 4 [[TMP4]], i32 40, i1 false), !dbg [[DBG215]]
// CHECK32-NEXT:    [[TMP5:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG218:![0-9]+]]
// CHECK32-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP5]], 1, !dbg [[DBG218]]
// CHECK32-NEXT:    store i32 [[ADD]], i32* [[A_ADDR]], align 4, !dbg [[DBG218]]
// CHECK32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[B1]], i32 0, i32 2, !dbg [[DBG220:![0-9]+]]
// CHECK32-NEXT:    [[TMP6:%.*]] = load i32, i32* [[ARRAYIDX]], align 4, !dbg [[DBG221:![0-9]+]]
// CHECK32-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP6]], 1, !dbg [[DBG221]]
// CHECK32-NEXT:    store i32 [[ADD2]], i32* [[ARRAYIDX]], align 4, !dbg [[DBG221]]
// CHECK32-NEXT:    call void @__kmpc_target_deinit(%struct.ident_t* @[[GLOB23:[0-9]+]], i1 false), !dbg [[DBG222:![0-9]+]]
// CHECK32-NEXT:    ret void, !dbg [[DBG223:![0-9]+]]
// CHECK32:       worker.exit:
// CHECK32-NEXT:    ret void, !dbg [[DBG215]]
//
//
// CHECK32-LABEL: @__omp_offloading_2a_cee46c__Z9ftemplateIiET_i_l57(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK32-NEXT:    [[B_ADDR:%.*]] = alloca [10 x i32]*, align 4
// CHECK32-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata i32* [[A_ADDR]], metadata [[META227:![0-9]+]], metadata !DIExpression()), !dbg [[DBG228:![0-9]+]]
// CHECK32-NEXT:    store [10 x i32]* [[B:%.*]], [10 x i32]** [[B_ADDR]], align 4
// CHECK32-NEXT:    call void @llvm.dbg.declare(metadata [10 x i32]** [[B_ADDR]], metadata [[META229:![0-9]+]], metadata !DIExpression()), !dbg [[DBG228]]
// CHECK32-NEXT:    [[TMP0:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 4, !dbg [[DBG230:![0-9]+]]
// CHECK32-NEXT:    [[TMP1:%.*]] = load i32, i32* [[A_ADDR]], align 4, !dbg [[DBG230]]
// CHECK32-NEXT:    [[TMP2:%.*]] = load [10 x i32]*, [10 x i32]** [[B_ADDR]], align 4, !dbg [[DBG230]]
// CHECK32-NEXT:    call void @__omp_offloading_2a_cee46c__Z9ftemplateIiET_i_l57_debug__(i32 [[TMP1]], [10 x i32]* [[TMP2]]) #[[ATTR3]], !dbg [[DBG230]]
// CHECK32-NEXT:    ret void, !dbg [[DBG230]]
//
